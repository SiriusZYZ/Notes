
# ==动态规划I==

# 509.斐波那契数

[link](https://leetcode.cn/problems/fibonacci-number/description/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

**输入：** n = 2
**输出：** 1
**解释：** F(2) = F(1) + F(0) = 1 + 0 = 1

**示例 2：**

**输入：** n = 3
**输出：** 2
**解释：** F(3) = F(2) + F(1) = 1 + 1 = 2

**示例 3：**

**输入：** n = 4
**输出：** 3
**解释：** F(4) = F(3) + F(2) = 2 + 1 = 3

**提示：**

-   `0 <= n <= 30`

## 思路
easy
```python
class Solution:
    def fib(self, n: int) -> int:

        if n == 0: return 0
        if n == 1: return 1

        pre, cur = 0, 1
        for i in range(n-1):
            pre, cur = cur, pre + cur
        
        return cur
```


# 70.爬楼梯

[link](https://leetcode.cn/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

**输入：** n = 2
**输出：** 2
**解释：** 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

**示例 2：**

**输入：** n = 3
**输出：** 3
**解释：** 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

**提示：**

-   `1 <= n <= 45`

## 思路

- 状态转移方程：`ways[i] = ways[i-1] + ways[i-2]`，初始状态为`ways=[1,2]`
```python
class Solution:
 
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n

        pre, cur = 1, 2
        for i in range(n-2):
            pre, cur = cur, pre + cur
        
        return cur
```


# 746.使用最小花费爬楼梯

[link](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

**输入：** cost = [10,_**15**_,20]
**输出：** 15
**解释：** 你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

**示例 2：**

**输入：** cost = [_**1**_,100,_**1**_,1,_**1**_,100,_**1**_,_**1**_,100,_**1**_]
**输出：** 6
**解释：** 你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。

**提示：**

-   `2 <= cost.length <= 1000`
-   `0 <= cost[i] <= 999`

## 思路

- 只需要原地修改，dp表保存的是从当前点起跳的最小成本。
- 状态转移方程为:`dp[i] = cost[i] + min(dp[i-1], dp[i-2])`

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(2, len(cost)):
            
            cost[i] += min(cost[i-1], cost[i-2])
        
        return min(cost[-1], cost[-2])
```


# 62.不同路径
[link](https://leetcode.cn/problems/unique-paths/description/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![[Pasted image 20230224095644.png]]

**输入：** m = 3, n = 7
**输出：** 28

**示例 2：**

**输入：** m = 3, n = 2
**输出：** 3
**解释：**
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

**示例 3：**

**输入：** m = 7, n = 3
**输出：** 28

**示例 4：**

**输入：** m = 3, n = 3
**输出：** 6

**提示：**

-   `1 <= m, n <= 100`
-   题目数据保证答案小于等于 `2 * 109`

## 思路

- 由于这一题中规定了机器人行进方向，即在一个方向上只能向前，因此可以很好地遍历
- 转移方程:`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
- 由于第一排和第一列上，可能的走法只有一路向右或一路向下，所以初始化为1
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        paths = [[0 for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i*j == 0: 
                    paths[i][j] = 1
                    continue
                
                paths[i][j] = paths[i-1][j] + paths[i][j-1]
        
        return paths[-1][-1]
```

# 63.不同路径 II

[link](https://leetcode.cn/problems/unique-paths-ii/description/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**
![[Pasted image 20230224102724.png]]
**输入：** obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
**输出：** 2
**解释：** 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 `2` 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

**示例 2：**
![[Pasted image 20230224102734.png]]


**输入：** obstacleGrid = [[0,1],[0,0]]
**输出：** 1

**提示：**

-   `m == obstacleGrid.length`
-   `n == obstacleGrid[i].length`
-   `1 <= m, n <= 100`
-   `obstacleGrid[i][j]` 为 `0` 或 `1`

## 思路

- 和上一题没啥差别，但是需要加个判断，即如果该处是有障碍的话，那该点直接就设置为0，否则可以按之前的规则更新。
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:

        if obstacleGrid[0][0] == 1:
            return 0

        m, n = len(obstacleGrid), len(obstacleGrid[0])
        paths = [[0 for j in range(n)] for i in range(m)]

        paths[0][0] = 1

        for i in range(1, m):
            if obstacleGrid[i][0] != 1: paths[i][0] = paths[i-1][0]
        for j in range(1, n):
            if obstacleGrid[0][j] != 1: paths[0][j] = paths[0][j-1]
        
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1: continue

                paths[i][j] = paths[i-1][j] + paths[i][j-1]
        

        return paths[-1][-1]
```


# 343.整数拆分

[力扣题目链接](https://leetcode.cn/problems/integer-break/)

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

-   输入: 2
-   输出: 1
-   解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

-   输入: 10
-   输出: 36
-   解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
-   说明: 你可以假设 n 不小于 2 且不大于 58。


## 思路

- `a = b + (a-b)` ，那展开乘积有两种可能：`b*(a-b)`及`(b展开的最大乘积)*(a-b)`
- 那么可以得出:
- `dp[a] = max(i){dp[i]*(a-i), i*(a-i)}`
```python
class Solution:
    
    def integerBreak(self, n: int) -> int:

        if n == 2: return 1

        dp = [0 for i in range(n+1)]
        dp[1] = 1

        for i in range(2, n+1):
            
            dp[i] = max([dp[j]*(i-j) for j in range(1, i)]+[j*(i-j) for j in range(1, i)])
            print(dp)
        
        return dp[n]
```


# 96.不同的二叉搜索树
[link](https://leetcode.cn/problems/unique-binary-search-trees/description/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![[Pasted image 20230224151236.png]]

**输入：** n = 3
**输出：** 5

**示例 2：**

**输入：** n = 1
**输出：** 1

**提示：**

-   `1 <= n <= 19`

## 思路
- 这类二叉树的树形有一个特点，就是`n`二叉树的根节点、左子树、右子树包含的元素个数是`1, i, n-1-i`。
- 由于平衡二叉树保证左子树所有节点都小于根节点和右子树所有元素，那么一个`n` 二叉树，确定根节点为`i`，那左子树必然就是`i-1`个元素，右子树是`n-i-1` 个元素
- 考虑此时的左子树，其包含了`[1, i-1]`里的所有数，其形状可能数就是`dp[i-1]`
- 考虑此时的右子树，其包含了`[i+1,n]`里的所有数，其形状可能数相当于`dp[n-i]`
- 显然，左右子树的形状可能数相乘就能得到根节点为`i`时的形状可能数

```python
class Solution:
    def numTrees(self, n: int) -> int:
        if n <= 2: return n

        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        dp[1] = 1
        dp[2] = 2

        for i in range(3, n+1):
            for j in range(i):
                dp[i] += dp[i-j-1] * dp[j]
        
        return dp[n]
```



# ==动态规划II : 01背包问题==


# 理论篇

![[Pasted image 20230224152954.png]]
- 根据物品数量的不同，可以将背包问题划分为不同类型
- 01背包问题 :  每个物品只有1个，选或者不选
- 完全背包问题 : 每个物品有无数个可供选择
- 多重背包问题 : 不同物品具有不同个数，实际这个问题可以转化为01背包问题？
- 分组背包问题 : 按组选择，每组最多选一个

需要关注的是01背包和完全背包

## 01背包的dp数组

假设数组`dp` 
`dp[item][volumn]` 储存从`[0, item]`中选取物品放入容量为`volumn`的背包中，最大的价值量。

递推公式:
- 从某个状态转移到item-volumn状态，有两种可能:
  - item没有放入背包中，那么:`dp[item][volumn] = dp[item-1][volumn]` 也就是说这和从`[0, item-1]`中选取物品放入背包是相同的。
  - item放入背包中了，那么新的价值应该是`dp[item-1][volumn-weight[item]] + value[item]` ，换而言之就是等价于当前物品价值加上从`[0,item-1]` 里面选物品放入`volumn-weight[item]` 背包里面，注意这种情况的前提条件是`volumn-weight[item]`，即只有当前物品重量小于整个背包容量才能放东西。

遍历顺序:
- 看个人理解，我们可以先遍历容量，再遍历物品。这样就相当于我们逐次确定当前物品堆中可以存放的最大价值是多少，然后再新增物品到堆中
- 可以先遍历物品再遍历容量。这样就相当于所有物品在容量中能有多少的最大价值，然后再扩充背包容量。

初始化
- 由于涉及到`[item-1]`行，而0行是不能求-1行的，因此需要初始化
- 对于`dp[0][vol]`，显然当`vol` 大于`weight[0]` 时，值就是`value[0]`

```python
def calculate(weight, value, N):

    dp = [[0 for vol in range(N+1)] for item in range(len(weight))]
    for vol in range(weight[0], N+1):

        dp[0][vol] = value[0]

    for vol in range(0, N+1):

        for item in range(1, len(weight)):

            dp[item][vol] = max(dp[item-1][vol],  (dp[item-1][vol-weight[item]]+ value[item]) if vol-weight[item] >= 0 else 0)

```

## 01背包的滚动数组

我们可以得到dp数组的更新方式:
`dp[item][vol] = max(dp[item-1][vol], (dp[item-1][vol-weight[item]] + value[item]) if vol > weight[item])`

由于当前状态仅取决于上一个item的所有状态，所以我们实际上只需要保留一行item即可，通过不断迭代更新item行完成任务。

所以我们可以假设新的数组:
`dp[vol]`代表容量vol下最大的价值。迭代公式就是:
`dp[vol] = max(dp[vol], dp[vol-weight[item]] + value[item] if vol > weight[item])`

- 现在问题是应该如何遍历？如果从0从小到大遍历，那么会出现这种情况:
  - `dp[3] = max(dp[3], dp[3-1]+2)`
  - `dp[4] = max(dp[4], dp[4-1]+2)`
  - 这里，vol=4的情况下有可能加入了两次item，一次是在vol=4, 一次是在vol=3，就会出问题
- 如果我们从大到小遍历，就可以避免这个问题，因为在遍历vol大的时候vol小的还保留的是item-1时的初值。

- 初始化：由于不记录item值，实际这个时候我们可以不进行初始化，这是因为我们只需假设item=-1为初始状态，item=0为首个迭代状态。在item=0时需要用到item=-1状态，而该状态所有value均为0，就能解决问题。

所以我们最后得到滚动数组:
```python
def calculate2(weight, value, N):

    dp = [0 for vol in range(N+1)]

    for item in range(len(weight)):

        for vol in range(N, -1, -1):

            dp[vol] = max(dp[vol], (dp[vol-weight[item]]+ value[item] if vol >= weight[item] else 0))

        print(dp)
```


# 416.分割等和子集

[力扣题目链接](https://leetcode.cn/problems/partition-equal-subset-sum/)
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1:

-   输入: [1, 5, 11, 5]
-   输出: true
-   解释: 数组可以分割成 [1, 5, 5] 和 [11].

示例 2:

-   输入: [1, 2, 3, 5]
-   输出: false
-   解释: 数组不能分割成两个元素和相等的子集.

提示：

-   1 <= nums.length <= 200
-   1 <= nums[i] <= 100

## 思路

如果将其构造成一道dp题，首先要确定weight, value,  volumn这三个分别是什么
我们的目标是子集求和的值到达总和的1/2
那么如果我们让容量volumn = 总和的1/2，每件物品的重量和价值都是nums中的数值，那么
1. 由于volumn限制，所以所选的数总和不超过数组总和1/2
2. 由于weight = value，所以`dp[vol]`得到的值是尽可能填到vol的值。

当`dp[sum//2] = sum//2`说明填满了


```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums = sum(nums)
        if sums %2 ==1:return False
        
        target = sums//2

        dp = [0 for vol in range(target+1)]
        for num in nums:
            for vol in range(target, -1, -1):
                dp[vol] = max(dp[vol], (dp[vol-num]+num) if vol >= num else 0)
            
        if dp[target] == target: return True
        
        return False
```


新的思路:
- 如果`dp[item][volumn] = volumn` 说明全部容量都装满了，而且装满的价值又恰好是容量，也就是选出了一个集合：
  1. 由volumn 限制，集合内元素总和不超过A
  2. 在1的限制条件下，集合内元素总和恰好为A
  3. 尽管很显然，集合内元素总和就是自身总和，但是对于dp，很可能出现这种情况，即:`dp[item][volumn] < volumn`，这种情况下，背包并未填满，而且又无法放下更多的东西。


- **对于上述问题，我们可以改造dp数组，令`dp[item][volumn]` 代表从前item个元素中是否能构成和恰好为volumn的集合。**
`dp[item][volumn] = func(dp[item-1][volumn], dp[item-1][volumn-weight]+weight)`

- 如果选择的是`dp[item-1][volumn]`，即不往当前集合中加元素，那么`dp[item][volumn] = dp[item-1][volumn] = volumn`， 也就是说`dp[item-1][volumn]`和`dp[item-1][volumn]` 布尔值相同
- 如果选择的是`dp[item-1][volumn-weight]+weight`，即往当前集合中加元素`item[i]`，那么`dp[item][volumn] = dp[item-1]dp[item-1][volumn-weight]+weight= volumn`， 也就是说`dp[item-1][volumn]`和`dp[item-1][volumn]` 布尔值相同
- 这里说明：`dp[item][volumn]`为`dp[item-1][volumn] OR dp[item-1][volumn-weight]+weight`

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums = sum(nums)
        if sums %2 ==1:return False
        
        target = sums//2

        dp = [False for vol in range(target+1)]
        dp[0] = True

        for item in range(len(nums)):
            for vol in range(target, nums[item]-1, -1):
                dp[vol] |= dp[vol-nums[item]]
            
        return dp[target]
       
```

# 1049.最后一块石头的重量II

[连接](https://leetcode.cn/problems/last-stone-weight-ii/description/)
有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

-   如果 `x == y`，那么两块石头都会被完全粉碎；
-   如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

**输入：** stones = [2,7,4,1,8,1]
**输出：** 1
**解释：**
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

**示例 2：**

**输入：** stones = [31,26,33,21,40]
**输出：** 5

**提示：**

-   `1 <= stones.length <= 30`
-   `1 <= stones[i] <= 100`

## 思路

- 本题的关键是认识到，如果将石头分成两组重量相近的两组`A`和`B`进行对撞，组内石头不对撞，最终剩下的石头重量为`sum(A)-sum(B)`
- 所以问题转换为，划分集合为两组总和之差尽可能小的
- 与416题相同，我们考虑符合要求的集合，而`dp`：
  1. 由volumn 限制，集合内元素总和不超过A
  2. 在1的限制条件下，集合内元素总和恰好为A
- 使用416的思路，`dp[volumn]_item` 代表从前item个元素是否能构成和为volumn的集合。对于可以的组合，我们考虑volumn的值和N-volumn的值之差有多小，即`abs(2*volumn-sum(stones))` 多小，并一直找到最小的那个。
- 由于划分集合是对称的，所以dp的volumn可以不超过sum/2，以此减少时间复杂度。

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:

        mini = total = sum(stones)
        N = mini//2
        dp = [False for vol in range(N+1)]
        dp[0] = True

        for item in range(len(stones)):
            for vol in range(N, stones[item]-1, -1):
                dp[vol] |= dp[vol-stones[item]]

                if dp[vol]  and abs(2*vol-total) < mini:
                    mini = abs(2*vol-total)
                    #print(mini)
            #print(dp)


        return mini
```



# 494.目标和
[连接](https://leetcode.cn/problems/target-sum/description/)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

-   例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

**输入：** `nums = [1,1,1,1,1], target = 3`
**输出：** 5
**解释：** 一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

**示例 2：**

**输入：** `nums = [1], target = 1`
**输出：** 1

**提示：**

-   `1 <= nums.length <= 20`
-   `0 <= nums[i] <= 1000`
-   `0 <= sum(nums[i]) <= 1000`
-   `-1000 <= target <= 1000`


## 思路
- 承袭上一题[1049.最后一块石头的重量II](#1049.最后一块石头的重量II), 由于每个数字之前只有+/-两种可能，所以我们可以认为把`nums`划分为两个集合`A`,`B` ，满足:
  - `sum(A) - sum(B) == target; `
  - `sum(A) + sum(B) == sum(nums)` 
  - 题目就转化为寻找构成`sum(A) = (target + sum(nums))/2` 集合A的可能构造方法。
- 与上一题又不同上一题中dp只关注该处能不能构成满足vol = value的集合，而这题关注的是构成这样集合的个数，因此dp含义有所不同，也必须采取不同的迭代方式
- 令`dp[vol]_item` 代表使用前item个数，能构成和为vol的集合的个数
- `dp[vol]_item` 有两种情况:
  1. 当`vol < nums[item]` ，即当前item 大于构造和，所以不可能将item 加入到集合中，那么只有一种可能即`dp[vol]_item = dp[vol]_item-1`，也就是说和前item-1个数构成何为vol的集合数量相同
  2. 当`vol >= nums[item]` ,也就是说，和为vol的集合可能包含item。
     - 不包含item的集合可能数为`dp[vol]_item-1`
     - 包含item的集合可能数位`dp[vol-nums[item]]_item-1`
     - 因此此时:`dp[vol]_item = dp[vol]_item-1 + dp[vol-nums[item]]_item-1`

- 最终，我们需要知道构成`sum(A) = (target + sum(nums))/2` 集合A的可能数目，将所有item 取完，而最大vol数为`(target + sum(nums))/2` ，求最后一次迭代的`dp[-1]`即可

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sums = sum(nums)
        target_vol = (sums + target)
        if target_vol % 2 == 1 or target_vol < 0:
            return 0
        else:
            target_vol = int(target_vol / 2)

        # dp[vol]_item = given item, how many ways to construct a set whose sum is vol
        dp = [0 for vol in range(target_vol+1)]
        dp[0] = 1   
        for item in range(len(nums)):
            for vol in range(target_vol, nums[item]-1, -1):
                dp[vol] += dp[vol - nums[item]] 
                
            #print(dp)
        
        return dp[target_vol]
```

# 474.一和零

[连接](https://leetcode.cn/problems/ones-and-zeroes/description/)
给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

**输入：** ` strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3`
**输出：** 4
**解释：** 最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

**示例 2：**

**输入：** `strs = ["10", "0", "1"], m = 1, n = 1`
**输出：** 2
**解释：** 最大的子集是 {"0", "1"} ，所以答案是 2 。

**提示：**

-   `1 <= strs.length <= 600`
-   `1 <= strs[i].length <= 100`
-   `strs[i]` 仅由 `'0'` 和 `'1'` 组成
-   `1 <= m, n <= 100`

## 思路

- 通过研究发现，之前的每一道题都有一个相似点，就是返回的值和dp数组的含义是相关的。
  - 比如[分隔等和子集](#416.分割等和子集)，我们返回的答案是能不能分隔成功，所以dp含义是当前volumn和item能不能恰好凑成价值为volumn的集合。
  - 比如[最后一块石头的重量](#1049.最后一块石头的重量II) ，我们本质上返回的是是否能构成容量尽可能接近sum/2的集合，所以dp含义是当前volumn和item能不能恰好凑成价值为volumn的集合。
  - 比如[目标和](#494.目标和) ， 我们需要返回的是某一特定容量的集合有多少中构造方式，因此dp含义是当前volumn和item构成价值为volumn的集合可能个数。
- 回到这一题，我们由于我们返回的是子集中元素的个数，所以我们可以假设dp含义是当前volumn和item能构成的最大子集。
- 本题与之前题目不同在于，控制volumn的变量有两个，即0个数和1个数，因此dp从一维滚动数组变成二维滚动矩阵。更新方式也是从尾巴开始更新。
- `dp[vol]_item` 的迭代有两种可能:
  - `item > vol` 即当前item超过允许的0和1数量，因此`dp[vol]_item = dp[vol]_item-1`
  - `item < vol` 即当前item可以加入到集合中:
    1. 选择item 加入，则集合个数为`dp[vol-item]+1`
    2. 选择item不加入，则集合个数为`dp[vol]_item-1`
    -  总的来说就是`dp[vol]_item = max(dp[vol]_item-1,dp[vol-item]+1`

```python
class Solution:
    def findMaxForm(self, strs: list, m: int, n: int) -> int:

        dp = [[0 for index0 in range(m+1)] for index1 in range(n+1)]

        for ele in strs:

            counts = [0, 0]
            for char in ele:
                counts[int(char)] += 1
            count0, count1 = counts

            for index1 in range(n, count1-1, -1):
                for index0 in range(m, count0 -1, -1):
                    dp[index1][index0] = max(dp[index1][index0], dp[index1-count1][index0-count0]+1)
            
        return dp[-1][-1]
```

# ==动态规划III:完全背包问题==

01背包中，每件物品只能选一次
`dp[item][vol] = max(dp[item-1][vol], dp[item-1][vol-item]+value)`

而完全背包中，每件物品可以选无数次
`dp[item][vol] = max(dp[item-1][vol], dp[item][vol-item]+value)`
- 如果我们根本不打算把item 放进背包里，那价值还是`dp[item-1][vol]`
- 如果我们打算把item 放进背包里，那当前价值就是`dp[item][vol-item]+value`。
  - 为什么不是item-1? 因为如果是item-1，那相当每个`dp[item][vol]`如果加入item 时，都只和`dp[item-1][vol]` 有关，即无论vol有多大，都只会加入一次当前item的value
  - 而如果是item 时，加入了一次以后，当vol_new>vol_old+item时，我们还能往背包中加入item的value，这样就实现了每件物品都可以放进去无数次。

考虑一维滚动数组:
鉴于`dp[item][vol] = max(dp[item-1][vol], dp[item][vol-item]+value)` ，我们可以得出结论，即完全背包的dp数组是从小vol到大vol遍历，从小item 到大item遍历的
不难写出:
```python

dp = [0 for vol in range(N+1)]
for item_index in range(len(weight)):
	for vol in range(weight[item_index], N+1):
		dp[vol] = max(dp[vol], dp[vol-weight[item_index]] + value[item_index])
```


# 动态规划中的组合和排列

考虑之前在回溯一章的做法:
- **我们每次创建一个分支，当前选择的item都作为当前排列的最后一个数。**
- 对于组合，我们会按一定顺序遍历数组内元素，从item开始的分支不会考虑item之前的所有数。这样，对于任意的集合，我们只会得到一个按照nums顺序排列的组合。
- 对于排列，我们仍按照一定顺序遍历数组内的元素，但是从item开始的分支可以考虑Nums所有数。这样对于任意的集合，我们得到多个排列。
- 尽管按照排列的方式我可以将item插入到排列中任意一个位置，但是这样会造成顺序的混乱。

如今，再考虑动态规划:
对于`dp[vol]`：
- 组合问题中`dp[vol]`里如果加入了当前Item，Item必然是当前所有可能组合的最后一个数。
- 排列问题中`dp[vol]`里，当前所有可能组合的最后一个数却可能是nums中的任意一个数。

根据以上考虑，我们可以得到，在计算`dp[vol]`时
- 组合问题只考虑`dp[vol-item]`的值，因此内层循环遍历vol
- 排列问题考虑所有`dp[vol-item]`的值，因此内层循环遍历item



# 518.零钱兑换II
[连接](https://leetcode.cn/problems/coin-change-ii/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

**输入：** amount = 5, coins = [1, 2, 5]
**输出：** 4
**解释：** 有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

**示例 2：**

**输入：** amount = 3, coins = [2]
**输出：** 0
**解释：** 只用面额 2 的硬币不能凑成总金额 3 。

**示例 3：**

**输入：** amount = 10, coins = [10] 
**输出：** 1

**提示：**
-   `1 <= coins.length <= 300`
-   `1 <= coins[i] <= 5000`
-   `coins` 中的所有值 **互不相同**
-   `0 <= amount <= 5000`


## 思路

- 由于可以加任意数目的硬币，所以是个完全背包问题
- 考虑返回值是组合数目大小，所以我们假设`dp[vol]_item` 代表前item个构成vol的不同集合数目
- `dp[vol]_item` 有两可能:
  1. 不加item情况的数目为`dp[vol]_item-1`
  2. 加item情况的数目为`dp[vol-item]_item`
- 所以`dp[vol]_item = dp[vol]_item-1 + dp[vol-item]_item`
- 关于初始化，由于vol=0是有可能凑出来的，但只有一个可能就是第一个硬币选择为不加，因此`dp[0] = 1` 

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0 for vol in range(amount +1)] 
        dp[0] = 1

        for item in range(len(coins)):
            for vol in range(coins[item], amount+1):
                dp[vol] += dp[vol-coins[item]]
            
            #print(dp)

        return dp[-1]  
```


# 377.组合总和Ⅳ

[连接](https://leetcode.cn/problems/combination-sum-iv/description/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

**输入：** nums = [1,2,3], target = 4
**输出：** 7
**解释：**
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。

**示例 2：**

**输入：** nums = [9], target = 3
**输出：** 0

**提示：**

-   `1 <= nums.length <= 200`
-   `1 <= nums[i] <= 1000`
-   `nums` 中的所有元素 **互不相同**
-   `1 <= target <= 1000`


## 思路

- 注意本题是一道排列题，因此内层遍历应该遍历元素。
```python
class Solution:
    def combinationSum4(self, nums: list, target: int) -> int:

        dp = [0 for i in range(target + 1)]
        dp[0] = 1

        for vol in range(1, target+1):
            for item in nums:
                if vol >= item: dp[vol] += dp[vol-item]

            print(dp)
        
        return dp[-1]
```


# 70.爬楼梯-完全背包版
[70.爬楼梯](#70.爬楼梯)


假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

**输入：** n = 2
**输出：** 2
**解释：** 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

**示例 2：**

**输入：** n = 3
**输出：** 3
**解释：** 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

**提示：**

-   `1 <= n <= 45`


## 思路
- 由于爬楼梯爬多少步先后有顺序，所以这题属于排列题。
- 这和377是一个题，不过这一题中，nums数组被限定为`[1,2]`， 所以好写很多。如果我们爬梯的步数可以是小于m的任意步数，则nums数组就变成`[1,2....m]` 但实际解决办法都是一样的。
```python
class Solution:
 
    def climbStairs(self, n: int) -> int:
        
        dp = [0 for level in range(n+1)]
        dp[0] = 1

        for level in range(1, n+1):
            for step in range(1, 3):
                if level >= step: dp[level] += dp[level-step]
        
        #print(dp)
        return dp[n]
```

# 322.零钱兑换
[连接](https://leetcode.cn/problems/coin-change/description/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

**输入：** coins = `[1, 2, 5]`, amount = `11`
**输出：**`3` 
**解释：** 11 = 5 + 5 + 1

**示例 2：**

**输入：** coins = `[2]`, amount = `3`
**输出：**-1

**示例 3：**

**输入：** coins = [1], amount = 0
**输出：** 0

**提示：**

-   `1 <= coins.length <= 12`
-   `1 <= coins[i] <= 231 - 1`
-   `0 <= amount <= 104`

## 思路

- **dp的定义:** 由于他想知道最少的硬币数是多少，所以我们可以让`dp[vol]` 数组保存到vol的最小硬币数
- **dp的遍历:** 我们必须考虑，比如我找零10块钱，给客户的最后一个硬币可能是coins中的所有硬币。那我就知道内层遍历是遍历coins。
- **dp的递推**: 找零十块钱，我有1,2,5三种钱，那可能组合是:
  - 已经找好的9元+1元，即钱币数为`dp[9]+1`
  - 已经找好的8元+2元，即钱币数为`dp[8]+1`
  - 已经找好的5元+5元，即钱币数为`dp[5]+1`
  - 要从以上集合中找到钱币数最少的，那我遍历的时候就留意其中的最小值即可，即`dp[vol] = min(dp[vol], dp[vol-coin] +1)`
- **dp的初始化**: 由于题目说了，如果你凑不出来是要返回-1的，我们必须要想办法在dp中保留“凑不出来”这件事。可行的方法是，我们设定一个值来表示凑不出来。这个值可以是某个超大的值，也可以是amount+1。因为题目说了最小的钱币是1，所以不可能最少钱币数超过amount+1。因此:`dp = [amount+1 for __ in range(amount+1)]`。又因为amount可能为0，这种情况最少钱币数为0，所以`dp[0]=0`

```python
class Solution:
    def coinChange(self, coins: list, amount: int) -> int:
        dp = [amount+1 for pocket in range(amount+1)]
        dp[0] = 0

        for pocket in range(amount+1):
            for coin in coins:
                if pocket >= coin:
                    dp[pocket] = min(dp[pocket], dp[pocket-coin]+1)
        
        print(dp)

        if dp[-1] == amount+1: return -1
        return dp[-1]
```


# 0279.完全平方

[连接](https://leetcode.cn/problems/perfect-squares/description/)
给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

**输入：** n = `12`
**输出：** 3 
**解释：**`12 = 4 + 4 + 4`

**示例 2：**

**输入：** n = `13`
**输出：** 2
**解释：**`13 = 4 + 9`

 

**提示：**

-   `1 <= n <= 10^4`


## 思路

- 由于这题可以放无数个同样的完全平方数，所以是完全背包问题
- 与之前的零钱兑换相似，对于每个vol我们都要计算它最少的组合数，为了方便理解，遍历顺序我就按内层遍历完全平方数
- 为了优化，我们可以发现每次内层遍历的数都是会变的，因为随着vol增加，其可能包含的完全平方数就会越来越多

```python
import math
class Solution:
    def numSquares(self, n: int) -> int:
        
        dp = [i for i in range(n+1)]
        
        for vol in range(1, n+1):
            for n in range(1, int(math.sqrt(vol))+1):
                #print(n)
                dp[vol] = min(dp[vol-n*n]+1, dp[vol])
        
        #print(dp)

        return dp[-1]
```

- 我还发现，就`n*n` 运算是比`n**2` 快很多的，因此尽量减少幂次计算


# 139.单词拆分
[连接](https://leetcode.cn/problems/word-break/description/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

**输入:** s = "leetcode", wordDict = `["leet", "code"]`
**输出:** true
**解释:** 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

**示例 2：**

**输入:** s = "applepenapple", wordDict = `["apple", "pen"]`
**输出:** true
**解释:** 返回 true 因为 `"`applepenapple`"` 可以由 `"`apple" "pen" "apple`" 拼接成`。
     注意，你可以重复使用字典中的单词。

**示例 3：**

**输入:** s = "catsandog", wordDict = `["cats", "dog", "sand", "and", "cat"]`
**输出:** false

**提示：**

-   `1 <= s.length <= 300`
-   `1 <= wordDict.length <= 1000`
-   `1 <= wordDict[i].length <= 20`
-   `s` 和 `wordDict[i]` 仅有小写英文字母组成
-   `wordDict` 中的所有字符串 **互不相同**

## 思路
- 由于这题worddict里面的东西可以添加任意次，所以是完全背包
- 我们可以把`dp[i]` 设置为s的前i个字母是否能被worddict凑出，那`dp[i]`就和`dp[i-len(word)]` 和`s[i-len(word):i]`有关，如果`s[:i-len(word)]` 能凑出，而`s[i-len(word):i] == word` 说明当前可以凑出
- 优化：减少单词遍历次数
```python
class Solution:
    def wordBreak(self, s: str, wordDict: list) -> bool:

        dp = [False for length in range(len(s)+1)]
        dp[0] = True

        for length in range(1, len(s)+1):
            for word in wordDict:
                if len(word) <= length and dp[length - len(word)] and word == s[length - len(word):length]:
                    dp[length] = True
                    #print(word)
                    break
        #print(dp)

        return dp[-1]
```


# 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

**输入：**`[1,2,3,1]`
**输出：** 4
**解释：** 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**

**输入：**`[2,7,9,3,1]`
**输出：** 12
**解释：** 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示：**

-   `1 <= nums.length <= 100`
-   `0 <= nums[i] <= 400`

## 思路

1. 首先我们想：dp数组的定义是什么：因为我们返回的东西就是到当前房子的最大打劫财富，所以dp应该存放的就是这个。
2. 接下来我们考虑dp数组的迭代方式：
   - 抢房子i：则i-1必不抢。所以此时最大财富为`dp[i-2] + nums[i]`
   - 不抢房子i：为求最大值，此时最大财富应该为`dp[i-1]`
   - 总结就是：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
3. 我们再考虑dp数组的初始化
   - 由于dp数组更新考虑前两个的值，所以初始化应该更新`dp[0], dp[1]`
   - `dp[0]` 显然是`nums[0]` 
   - `dp[1]` 显然是`max(nums[0], nums[1])`


```python
class Solution:
    def rob(self, nums: List[int]) -> int:

        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]

        dp = [0 for i in range(len(nums))]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        
        return dp[-1]
```

# 337.打家劫舍III

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 _**在不触动警报的情况下** ，小偷能够盗取的最高金额_ 。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

**输入:** root = `[3,2,3,null,3,null,1]`
**输出:** 7 
**解释:** 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7

**示例 2:**

![](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

**输入:** root = `[3,4,5,1,3,null,1]`
**输出:** 9
**解释:** 小偷一晚能够盗取的最高金额 4 + 5 = 9

**提示：**

-   树的节点数在 `[1, 104]` 范围内
-   `0 <= Node.val <= 104`

## 思路

- 当前节点抢不抢，这和子节点和孙子节点都有关系！
- 然而rob函数只能返回一个值，所以应该新开一个函数`treversal()`可以返回两个值
- 我们设定`traversal(root)`返回两个值，值1为选`root`情况下最大的财富数量，值2为不选`root`情况下最大的财富数量。
- 选root情况：
  孙子节点值1之和加上root的值
- 不选root情况：
  子节点值1之和
  
```python
class Solution:
    def rob(self, root) -> int:

        return self.traversal(root)[0]

    def traversal(self, root) -> list:

        dp0 = [0]
        dp1 = [0]

        if not root: 
            return [0, 0]
        
        if root.left:
            result = self.traversal(root.left)
            dp0.append(result[1])
            dp1.append(result[0])

        if root.right:
            result = self.traversal(root.right)
            dp0.append(result[1])
            dp1.append(result[0])         
        

        #print(root.val, dp0, dp1)
        dp1 = sum(dp1)
        dp0 = max(sum(dp0) + root.val, dp1)
        
       
        return [dp0, dp1]
```


# 122.买股票的最佳时机II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。

**示例 1：**

**输入：** prices = [7,1,5,3,6,4]
**输出：** 7
**解释：** 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。

**示例 2：**

**输入：** prices = [1,2,3,4,5]
**输出：** 4
**解释：** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。

**示例 3：**

**输入：** prices = [7,6,4,3,1]
**输出：** 0
**解释：** 在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。

**提示：**

-   `1 <= prices.length <= 3 * 104`
-   `0 <= prices[i] <= 104`


## 思路
- 使用dp来解决这类问题时，需要维护两个状态：
  - 当前持有股票`dp[i][0]`
  - 当前不持有股票`dp[i][1]`
  - 我们假设当前dp数组是我们的资产，我们的初始资产应为0
- 对于当前i持有股票的状态，他可能：
  - i-1本身就持有了股票，即`dp[i-1][0]`
  - i-1时未持有股票，当天购买股票，即`dp[i-1][1] - prices[i]`
- 对于当前i未持有股票，他可能：
  -  i-1本身就没持有股票，即`dp[i-1][1]`
  - i-1时未持有股票，当天购买股票，即`dp[i-1][1] - prices[i]`

- 我们再来考虑初始状态，
  - 第0天本身不持有, `dp[0][1] = 0`
  - 第0天买入，`dp[0][0] = -prices[0]`
- 迭代方式是:
  `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[0])`
  `dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])`

```python
class Solution:
    def maxProfit(self, prices: list) -> int:
        
        #if len(prices == 1): return 0

        # dp[i][0]: 持有股票时的最大收益
        # dp[i][1]: 不持有股票时的最大收益
        dp = [[0 for i in range(2)] for i in range(len(prices))]
        dp[0][0] = -prices[0]


        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        
        #print(dp)
        return max(dp[-1])
```


# 123.买卖股票的最佳时机III


给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**输入：** prices = [3,3,5,0,0,3,1,4]
**输出：** 6
**解释：** 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

**示例 2：**

**输入：** prices = [1,2,3,4,5]
**输出：** 4
**解释：** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

**示例 3：**

**输入：** prices = [7,6,4,3,1] 
**输出：** 0 
**解释：** 在这个情况下, 没有交易完成, 所以最大利润为 0。

**示例 4：**

**输入：** prices = [1]
**输出：** 0

**提示：**

-   `1 <= prices.length <= 105`
-   `0 <= prices[i] <= 105`


## 思路

- 这题和上一题相似，我们假设4种状态：
  0. 一直未持有股票
  1. 持有股票但未曾出售过
  2. 未持有股票，出售过1次股票
  3. 持有股票，出售过1次股票
  4. 未持有股票，出售过2次股票
- 那么，迭代的方式应该是：

我们继续考虑这4种状态，可以发现同一天先卖出后买入是和继续持有一样的。这种情况我们最终得到的利润都是一样的，但是后者却消耗了一次购买机会，所以我们应该默认一天内只进行一次交易。于是每个时间点都之和上一个时间点有关，而当前时间点种所有状态互相没有关系。

1. 持有股票但未曾出售过
  - 有可能是今天买了股票
  - 有可能是继续持有股票
  - `dp[i][0] = max(dp[i-1][0], -prices[i])`
2. 未持有股票，出售过一次股票
   - 有可能是今天卖了第一次买的股票
   - 有可能是继续不持有股票
   - `dp[i][1] = max(dp[i-1][1] + prices[i], dp[i-1][1])`
3. 持有股票，出售过一次股票
   - 有可能是今天买了第二次股票
   - 有可能是继续持有股票
   - `dp[i][2] = max(dp[i-1][1] - prices[i], dp[i-1][2])`
4. 未持有股票，出售过2次股票
   - 有可能是今天卖了第二次买的股票
   - 有可能是继续不持有股票
   - `dp[i][3] = max(dp[i-1][2] + prices[i], dp[i-1][3])`

- 结合以上结论，我们初始化时2，3，4情况需要初始化成什么值。在第一天这些都是不可能存在的情况(因为一天内只做一次交易）。但是从第二天开始每次迭代的时候，这些情况仍然参与迭代，特别是情况4：`dp[i-1][2] + prices[i]`项值会逐渐递增，知道盖过本应该算出来的最后一次出售股票的利润。
- 由此，我们实际上应该设置情况2，4这种可能出现累加的地方初始值为极小值，如`sum(prices)`或者直接设置其为`-10**10`等

- 最后返回的值我们还需要和0比大小。因为1，2，3，4四种情况是不完备的，缺少了一直不买这个可能。如果股票价格一直递减，而只考虑1，2，3，4，最好的情况就是只亏第一天的钱。但是实际上最好的结果就是直接不买，一分钱不亏。

```python
class Solution:
    def maxProfit(self, prices: list) -> int:

        dp = [[-100000 for status in range(4)] for date in range(len(prices))]

        dp[0][0] = -prices[0]

        for date in range(1, len(prices)):
            dp[date][0] = max(dp[date-1][0], - prices[date])
            dp[date][1] = max(dp[date-1][0] + prices[date], dp[date-1][1])
            dp[date][2] = max(dp[date-1][1] - prices[date], dp[date-1][2])
            dp[date][3] = max(dp[date-1][2] + prices[date], dp[date-1][3])

       # print(dp)    
        return max(0, max(dp[-1]))
```


# 188.买卖股票的最佳时机IV

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格，和一个整型 `k` 。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

**输入：** k = 2, prices = [2,4,1]
**输出：** 2
**解释：** 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

**示例 2：**

**输入：** k = 2, prices = [3,2,6,5,0,3]
**输出：** 7
**解释：** 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

**提示：**

-   `0 <= k <= 100`
-   `0 <= prices.length <= 1000`
-   `0 <= prices[i] <= 1000`


## 思路

- 这一题和上一题一个思路，如果可以做k次交易，那么就有2k个交易状态+1个一直不买状态
- 每个交易状态分持有和非持有，持有的和非持有的迭代逻辑区别在于是上一时刻上一状态值加上还是减去当前的股票价格
- 同样注意0状态和初始值设置
- 还需要注意k = 0时不能交易，直接返回0就行
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:

        if k == 0: return 0
        dp = [[-100000 for status in range(2 * k)] for date in range(len(prices))]

        dp[0][0] = -prices[0]

        for date in range(1, len(prices)):
            dp[date][0] = max(dp[date-1][0], - prices[date])
            dp[date][1] = max(dp[date-1][0] + prices[date], dp[date-1][1])


            for status in range(1, k):
                dp[date][2*status] = max(dp[date-1][2*status-1] - prices[date], dp[date-1][2*status])
                dp[date][2*status+1] = max(dp[date-1][2*status] + prices[date], dp[date-1][2*status+1])
            

       # print(dp)    
        return max(0, max(dp[-1]))
```



# 309.最佳买卖股票时机含冷冻期
[309.最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组`prices`，其中第  `prices[i]` 表示第 `_i_` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

-   卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

**输入:** prices = [1,2,3,0,2]
**输出:** 3 
**解释:** 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**

**输入:** prices = [1]
**输出:** 0

**提示：**

-   `1 <= prices.length <= 5000`
-   `0 <= prices[i] <= 1000`

## 思路
- 一共三种状态：
  0. 持有股票
  1. 当天出售了股票
  2. 不持有股票(不含冷冻期)
  3. 冷冻期

- 持有股票:
  - 可能是从冷冻期结束后当天购入股票`dp[i-1][3] - prices[i]`
  - 可能是从不持有股票(不含冷冻期)购入股票`dp[i-1][2] - prices[i]`
  - 一直持有股票`dp[i-1][0]`
  - `dp[i][0] = max(dp[i-1][0], dp[i-1][3] - prices[i], dp[i-1][2] - prices[i])`

- 当天出售了股票：
  - `dp[i][1] = dp[i-1][0] + prices[i]`

- 不持有股票(不含冷冻期)：
  - 前一天是冷冻期
  - 一直都没持有股票`dp[i-1][2]`
  - `dp[i][2] = max(dp[i-1][2], dp[i-1][0] + prices[i])`

- 冷冻期：
  - 只有一种可能，即前一天卖了股票，那其利润为`dp[i-1][1]`

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0] * 4 for _ in range(n)]
        dp[0][0] = -prices[0] 
        
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])
            dp[i][2] = dp[i-1][0] + prices[i]
            dp[i][3] = dp[i-1][2]
        
        return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])
```

# 714.买卖股票的最佳时机含手续费

[714.买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：** 这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

**输入：** prices = [1, 3, 2, 8, 4, 9], fee = 2
**输出：** 8
**解释：** 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

**示例 2：**

**输入：** prices = [1,3,7,5,10,3], fee = 3
**输出：** 6

**提示：**

-   `1 <= prices.length <= 5 * 104`
-   `1 <= prices[i] < 5 * 104`
-   `0 <= fee < 5 * 104`

## 思路
- 和[122.买股票的最佳时机II](#122.买股票的最佳时机II)的区别在于，每次买股票的时候需要你多花`fee`来支付费用，没啥大区别

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:

        
        dp = [[0 for i in range(2)] for i in range(len(prices))]
        dp[0][0] = -prices[0]-fee

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]-fee)
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] +  prices[i])
        
        #print(dp)
        return max(0, max(dp[-1]))
```

# 300.最长递增子序列
https://leetcode.cn/problems/longest-increasing-subsequence/

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

**输入：** nums = [10,9,2,5,3,7,101,18]
**输出：** 4
**解释：** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4 。

**示例 2：**

**输入：** nums = `[0,1,0,3,2,3]`
**输出：** 4

**示例 3：**

**输入：** nums = `[7,7,7,7,7,7,7]`
**输出：** 1

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

## 思路
- 我们假设`dp[i]`储存以`nums[i]` 为结尾的最长递增子序列长度
- 那么更新方式会这样：
  对于任意`j < i`：
  1. 当`nums[j] < nums[i]` ，则可以从`nums[j]`结尾的最长子序列后面加入`nums[i]`构成一个新的子序列
  2. 当`nums[j] >= nums[i]`， 则不行
- 由此，`dp[i]` 的值和任何小于i的dp都有关系
- 可以列出: `dp[i] = max(1, [dp[j]+1 for j in range(i) if nums[j] < nums[i]])

```python
class Solution:

    def lengthOfLIS(self, nums: list) -> int:
        
        n = len(nums)
        dp = [1 for i in range(n)]

        max_result = 1
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
            max_result = max(max_result, dp[i])

        return max_result
```



# 674.最长连续递增序列
https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/


给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

**示例 1：**

**输入：** nums = `[1,3,5,4,7]`
**输出：** 3
**解释：** 最长连续递增序列是` [1,3,5]`, 长度为3。
尽管` [1,3,5,7] `也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 

**示例 2：**

**输入：** nums = `[2,2,2,2,2]`
**输出：** 1
**解释：** 最长连续递增序列是` [2]`, 长度为1。

**提示：**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`


## 思路
- 比较简单，实际上都用不着动态规划
- 遍历过程中，设定两个变量
  1. `cur_len` 保存以当前数为结尾递增子序列最大长度
  2. `max_len` 保存目前最长的连续递增的子序列
- 每当`nums[i] <= nums[i-1]` 时说明递增子序列要改变了，变成`[nums[i]]`

```python
class Solution:
    def findLengthOfLCIS(self, nums: list) -> int:

        n = len(nums)
        cur_result, max_result = 1, 1 

        for i in range(1, n):
            if nums[i-1] < nums[i]:
                cur_result += 1
            else:
                max_result = max(max_result, cur_result)
                cur_result = 1
        
        return max(cur_result, max_result)
```


# 718.最长重复子数组

https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/
给两个整数数组 `nums1` 和 `nums2` ，返回 _两个数组中 **公共的** 、长度最长的子数组的长度_ 。

**示例 1：**

**输入：** nums1 =` [1,2,3,2,1]`, nums2 = `[3,2,1,4,7]`
**输出：** 3
**解释：** 长度最长的公共子数组是` [3,2,1]` 。

**示例 2：**

**输入：** nums1 = `[0,0,0,0,0]`, nums2 = `[0,0,0,0,0]`
**输出：** 5

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`
- 

## 思路


- 遇到这种题，题目里出现了两个数组，我们可以考虑使用二维的dp数组
- `dp[n1][n2]` 我们表示`nums1[0~n1]`和`nums2[0~n2]`两者尾部往前数两者相同的长度
> 例如
> nums1 = `[1,2,3,2,1]` , nums2 = `[3,2,1,4,7]`
> `dp[3][1]` 表示在`[1,2,3,2]`和`[3,2]`从尾部开始两者相同的长度 

- 迭代：从`nums1[0~n1-1]`和`nums2[0~n2-1]` 出发，如果有`nums1[n1] == nums2[n2]` 那么相当于在上一个状态下在尾部追加`nums1[n1] ` 和` nums2[n2]`：
- 即:`dp[n1][n2] = dp[n1-1][n2-1] + 1 if nums1[n1] == nums2[n2] else 0`

| nums1\\nums2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 0    | 0    | 1    | 0    | 0     |
- 刚开始，只有在`[1]`，和`[3,2,1]` 情况下找到重合的地方

| nums1\\nums2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 0   | 0   | 1   | 0   | 0   |
| 2             | 0     | 1     | 0     |0     |0     |
- 我们找到`nums1[1] = nums2[1]`，检查上一状态`dp[0][0] = 0`，也就是说上个状态没组成，所以`dp[1][1] = 0+1`

| nums1\\nums2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 0   | 0   | 1   | 0   | 0   |
| 2            | 0   | 1   | 0   | 0   | 0   |
| 3             |1     |0     |0     |0     |0     |
- 我们找到`nums1[2] = nums2[0]`，这里没有上一个状态，所以直接设置为1

| nums1\\nums2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 0   | 0   | 1   | 0   | 0   |
| 2            | 0   | 1   | 0   | 0   | 0   |
| 3            | 1   | 0   | 0   | 0   | 0   |
| 2             |0     |2     |0     |0     |0     |
- 我们首先找到`nums[3] = 2 = nums[1]`， 我们检查其上一个可能的状态即`dp[3-1][1-1] = 1`，上一个状态组成了，所以`dp[3][1] = dp[3-1][1-1] + 1 = 2`

| nums1\\nums2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 0   | 0   | 1   | 0   | 0   |
| 2            | 0   | 1   | 0   | 0   | 0   |
| 3            | 1   | 0   | 0   | 0   | 0   |
| 2            | 0   | 2   | 0   | 0   | 0   |
| 1             |0     |0     |3     |0     |0     |
- 我们首先找到`nums[4] = 1 = nums[2]`， 我们检查其上一个可能的状态即`dp[4-1][2-1] = 2`，上一个状态组成了，所以`dp[4][2] = dp[4-1][2-1] + 1 = 3`

- 最终我们要取整个dp的最大值，因为
  - 参考dp 定义：`dp`这里更多是说当前状态“尾部对齐的长度”，而不是“最长重复子数组长度”


```python
class Solution:
    def findLength(self, nums1, nums2) -> int:
        
        N1, N2 = len(nums1), len(nums2)
        

        dp = [[0 for i in range(N2)] for j in range(N1)]

        for i in range(N2):
            if nums1[0] == nums2[i]:    dp[0][i] = 1

        for j in range(N1):
            if nums2[0] == nums1[j]:    dp[j][0] = 1

        
        for n1 in range(1, N1):
            for n2 in range(1, N2):
                if nums1[n1] == nums2[n2]:
                    dp[n1][n2] = dp[n1-1][n2-1] + 1
        
        max_result = 0
        for n1 in range(N1):
            max_result = max(max_result, max(dp[n1]))

        return max_result
```

## 一维滚动数组思路

- 我们发现当前状态其实只和上一状态有关，那直接压缩成一维数组即可、遍历顺序从右边往左(即nums1正序遍历nums2逆序遍历)

| initial | 3   | 2   | 1   | 4   | 7   |
| --------- | --- | --- | --- | --- | --- |
| /        | 0   | 0   | 0   | 0   | 0   |

| nums1 = 1 | 3   | 2   | 1   | 4   | 7   |
| --------- | --- | --- | --- | --- | --- |
| 1         | 0   | 0   | 0>1   | 0   | 0   |

| nums1 = 2 | 3   | 2   | 1   | 4   | 7   |
| ------------ | --- | --- | --- | --- | --- |
| 2            | 0    | 0>1    | 1>0    | 0    | 0     |

| nums1 = 3 | 3   | 2   | 1   | 4   | 7   |
| --------- | --- | --- | --- | --- | --- |
| 3         | 0>1   | 1>0   | 0   | 0   | 0   |

| nums1 = 2 | 3   | 2   | 1   | 4   | 7   |
| --------- | --- | --- | --- | --- | --- |
| 2         | 1>0   | 0>1+1    | 0   | 0   | 0   |

| nums1 = 1 | 3   | 2   | 1   | 4   | 7   |
| --------- | --- | --- | --- | --- | --- |
| 1         | 0   | 2>0    | 0>2+1   | 0   | 0   |

```python
class Solution:
    def findLength(self, nums1, nums2) -> int:
        
        N1, N2 = len(nums1), len(nums2)

        dp = [0 for i in range(N2)]
        max_result = 0

        for n1 in range(N1):
            for n2 in range(N2-1, 0, -1):
                dp[n2] = dp[n2-1] + 1 if nums1[n1] == nums2[n2] else 0   
            dp[0] = 1 if nums1[n1] == nums2[0] else 0

            max_result = max(max_result, max(dp))
        


        return max_result
```

# 1143.最长公共子序列
https://leetcode.cn/problems/longest-common-subsequence/


给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

**输入：** text1 = "abcde", text2 = "ace" 
**输出：** 3  
**解释：** 最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

**输入：** text1 = "abc", text2 = "abc"
**输出：** 3
**解释：** 最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

**输入：** text1 = "abc", text2 = "def"
**输出：** 0
**解释：** 两个字符串没有公共子序列，返回 0 。

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

## 思路
- `dp[i][j]`：长度为`[0, i - 1]`的字符串text1与长度为`[0, j - 1]`的字符串text2的最长公共子序列为`dp[i][j]`
- 主要就是两大情况： `text1[i - 1]` 与` text2[j - 1]`相同，`text1[i - 1] `与` text2[j - 1]`不相同
  1. `text1[i - 1] == text2[j - 1]`：那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1`;
  2. `text1[i - 1] != text2[j - 1]`：那就看看`text1[0, i - 2]`与`text2[0, j - 1]`的最长公共子序列 和 `text1[0, i - 1]`与`text2[0, j - 2]`的最长公共子序列，取最大的。即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`;

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1, len2 = len(text1)+1, len(text2)+1
        dp = [[0 for _ in range(len1)] for _ in range(len2)] # 先对dp数组做初始化操作
        #print('  ','  '.join(text1))
        for i in range(1, len2):
            for j in range(1, len1): # 开始列出状态转移方程
                if text1[j-1] == text2[i-1]:
                    dp[i][j] = dp[i-1][j-1]+1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            
            #print(text2[i-1], dp[i][1:])
        
        return dp[-1][-1]
```


# 1035.不相交的线
[link](https://leetcode.cn/problems/uncrossed-lines/description/)
在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

**示例 1：**
![[Pasted image 20230607160459.png]]

**输入：** `nums1 = [1,4,2], nums2 = [1,2,4]`
**输出：** 2
**解释：** 可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 `nums1[1]=4` 到 `nums2[2]=4` 的直线将与从 `nums1[2]=2` 到 `nums2[1]=2 `的直线相交。

**示例 2：**

**输入：** `nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]`
**输出：** 3

**示例 3：**

**输入：** `nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]`
**输出：** 2

**提示：**

- `1 <= nums1.length, nums2.length <= 500`
- `1 <= nums1[i], nums2[j] <= 2000`


## 思路

- 稍加思考，其实可以发现这和上一题是一样的
- 也就是我们要从`nums1`中和`nums2`中选出一系列下标：
  1. `index1` 和`index2`长度相同
  2. 都是严格单调增的
  3. `nums1[index1] == nums2[index2]`
  4. 尽可能得到最长的`index` 长度
- 我们假设`dp[i][j]` 代表从`nums1[0] ~ nums1[i]` 和 `nums2[0] ~ nums2[j]` 找到的线数量
- 两种情况：
  1. `nums1[i] == nums2[j]`：那么可以画一条线。考虑index1，index2都是严格单调增，且这一状态要从`nums1[0] ~ nums1[i-1]` 和 `nums2[0] ~ nums2[j-1]` 而来，所以`dp[i][j] = dp[i-1][j-1] + 1`
  2. `nums1[i] != nums2[j]`：不能画线。可能从`[i][j-1]`和`[i-1][j]` 两个状态而来，求这两个状态的最大值即可

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
            
        N1, N2 = len(nums1), len(nums2)
        # dp[n1][n2]
        dp = [[0 for n2 in range(N2+1)] for n1 in range(N1+1)]

        for n1 in range(1, N1 + 1):
            for n2 in range(1, N2 + 1):
                if nums1[n1 - 1] == nums2[n2 - 1]:
                    dp[n1][n2] = dp[n1 - 1][n2 - 1] + 1
                else:
                    dp[n1][n2] = max(dp[n1-1][n2], dp[n1][n2-1])
            #print(nums1[n1 - 1], dp[n1][1:])
        
        return dp[-1][-1]
```