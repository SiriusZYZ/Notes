# 时间复杂度
**时间复杂度是一个函数，它定性描述该算法的运行时间**。
- 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，==随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同==，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。
- 算法导论给出的解释：**大O用来表示上界的**
- **业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界**。
- 同一个函数处理同样规模数据，如果它的数据样例不一样，可能时间复杂度就不一定一样！
  >输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是O(n)，但如果数据是逆序的话，插入排序的时间复杂度就是O(n^2)，也就对于所有输入情况来说，最坏是O(n^2) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。
  >同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，**所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)**。**但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界**。



# 时间复杂度意味着什么
- **当数据规模足够大时， 时间复杂度差异才会显著起来**：
  - 小规模数据，$O(n^2)$可能与$O(n)$不相上下，如果前者不带常数项而后者带，那可能前者好一点
  - 一般来说时间复杂度都不带常数项，这是指数据规模已经达到常数项不起作用的情况(无论常数项是和项还是倍乘项)
  - **所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示**：
    O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶

- 其他：
  - logn 对数底不指定，这是因为不同底的对数可以通过倍乘转换