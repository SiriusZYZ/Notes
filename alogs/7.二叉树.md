


# 理论篇

==节点的度==
> 指某个节点拥有的子树数目

==树的度==
> 指整棵树中节点最大的度

## 二叉树的种类
---
### 满二叉树

- 该树只有度为0的节点和度为2的节点
- 度为0的节点在同一层
- 树的节点数为$2^k-1$ ，其中$k$ 为层数
![[Pasted image 20221226140755.png]]

### 完全二叉树
- 除最底层节点**可能**未填满外，其余层每层节点均填满
- 最底层的所有节点均集中最左边
- 若最底层为第h层，该层可包含$1——2^{h-1}$ 个节点
- 满二叉树是完全二叉树
![[Pasted image 20221226141232.png]]

### 二叉搜索树
二叉搜索树是一个有序树，对于树中的任意节点：
- 若其左子树不为空，则左子树上所有节点值均小于该节点值
- 若其右子树不为空，则右子树上所有节点值均大于该节点值
![[Pasted image 20221226141827.png]]


### 平衡二叉搜索树(AVL)
(Adelson-Velsky and Landis)树，在平衡二叉树的基础上对数的深度有要求：
对于树中的任意节点：
- 若其左子树不为空，则左子树上所有节点值均小于该节点值
- 若其右子树不为空，则右子树上所有节点值均大于该节点值
- 其左右子树的高度差绝对值不超过1

![[Pasted image 20221226142156.png]]


## 二叉树的储存方式
---
二叉树可以链式储存，也可以顺序储存
- 链式储存:
![[Pasted image 20221226143733.png]]
- 数组储存：下标为`i`的节点左子下标为`2*i+1` ,右子下标为`2*i+2` 
![[Pasted image 20221226143759.png]]

## 二叉树遍历方式

- 深度优先遍历： 先一步步往深处走，遇到叶子节点(度为0)才往回走
  - 前中后表示了什么时候遍历中间节点
  - 前序遍历(递归法，迭代法)：
    1. 从根节点开始遍历
    2. 若当前节点非叶子节点，则先访问根节点，再遍历左子树，最后遍历右子树
    3. 若当前节点为叶子节点，则返回
 - 中序遍历(递归法，迭代法)：
    1. 从最左边叶子结点开始遍历
    2. 若当前节点非叶子节点，则先遍历左子树，再访问根节点，最后遍历右子树
    3. 若当前节点为叶子节点，则返回
 - 后序遍历(递归法，迭代法)：
    1. 从最左边叶子结点开始遍历
    2. 若当前节点非叶子节点，则先遍历左子树，再遍历右子树，最后访问根节点
    3. 若当前节点为叶子节点，则返回
![[Pasted image 20221226150712.png]]
- 广度优先遍历：层次遍历，一层一层遍历

# ==二叉树的遍历==

# 利用python构造二叉树
---
## 链表法
```python
class TreeNode:
	def __init__(self, val=0, left=None, right=None):
		self.val = val
		self.left = left
		self.right = right
```





# 二叉树的递归遍历
-   [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
-   [145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
-   [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

递归主要控制的先遍历哪一个地方:

## 前序遍历：
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        if root:
            return self.recursion(root)  
        else: 
            return []

    def recursion(self, node):
       
        result = [node.val]
        
        if node.left:
            result.extend(self.recursion(node.left))
        if node.right:
            result.extend(self.recursion(node.right))
        
        return result
```

## 后序遍历:
```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if root:
            return self.recursion(root)  
        else: 
            return []

    def recursion(self, node):
       
        result = list()
        
        if node.left:
            result.extend(self.recursion(node.left))
        if node.right:
            result.extend(self.recursion(node.right))
        result.append(node.val)
        
        return  result
```

## 中序遍历:
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if root:
            return self.recursion(root)  
        else: 
            return []

    def recursion(self, node):
       
        result = list()

        if node.left:
            result.extend(self.recursion(node.left))
        result.append(node.val)
        if node.right:
            result.extend(self.recursion(node.right))
        
        return  result
```


# 二叉树的迭代遍历

用栈实现：栈保存了路过的节点，入栈代表路过了，出栈代表该节点已经被正确地访问

### 前序遍历
- 初始化：根节点入栈
- 循环：当栈不为空
  - 弹出一个元素
  - 将元素放入结果数组
  - 存在时，将当前元素的右子入栈
  - 存在时，将当前元素的左子入栈

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        if not root: return list()

        stack = list()
        result = list()
        stack.append(root)
        while(stack):
            x = stack.pop()
            result.append(x.val)  

            if x.right: stack.append(x.right)
            if x.left: stack.append(x.left)
        
        return result
```

其核心是把弹出元素后把该元素的右左子入栈

### 后序遍历
前序遍历是：中-左-右
后序遍历是：左-右-中

因此后续遍历=(中-右-左).reverse()
不难写出代码:
```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if not root: return list()

        stack = list()
        result = list()
        stack.append(root)
        while(stack):
            x = stack.pop()
            result.append(x.val)  

            if x.left: stack.append(x.left)
            if x.right: stack.append(x.right)
            
        
        return result[::-1]
```

### 中序遍历
中序遍历是：左-中-右
这样无法使用上面的技巧



- 一路向左走，这导致栈一路保存访问过的节点，同时也一路更新左节点
- 当当前节点不空
  - 将当前节点入栈
  - 当前节点=当前节点左子（**往左走的表现**）
- 当当前节点是空的，说明它的父节点应该弹出（因为左-中-右的关系，左已经空所以中就是下一个）
  - 当前节点=弹出栈（**因为当前栈顶保存的是当前节点的父节点**）
  - 将当前节点加入列表
  - 当前节点=当前节点右子（因为已经把左、中都访问过了，所以接下来访问右边）

总的来说，可以这样实现:

- 初始化： 当前节点为根节点
- 循环：当当前节点或栈存在
  - 如果当前节点非空：
    - 当前节点入栈
    - 当前节点=当前节点左子
  - 否则：
    - 当前节点=出栈
    - 当前节点加入结果中
    - 当前节点=当前节点右子


所以实现是:
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if not root: return []

        stack, result = list(), list()
        cur = root

        while(cur or stack):
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
        
        return  result
```


# 二叉树的层序遍历

[102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**输入：**root = [3,9,20,null,null,15,7]
**输出：**[[3],[9,20],[15,7]]

**示例 2：**

**输入：**root = [1]
**输出：**[[1]]

**示例 3：**

**输入：**root = []
**输出：**[]

**提示：**

-   树中节点数目在范围 `[0, 2000]` 内
-   `-1000 <= Node.val <= 1000`

## 思路：
- 创造一个队列，里面保存当前层的所有节点
- 出队时把节点放到暂存组中，然后把节点可能存在的左右子节点入队尾。做完以后则暂存组append到结果中
- 反复上述操作直到队列为空
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:

        if not root : return []

        from collections import deque

        mq = deque()
        mq.append(root)

        result = list()

        while(mq):
            layer = list()
            for _ in range(len(mq)):
                x = mq.popleft()
                layer.append(x.val)
                if x.left:  mq.append(x.left)
                if x.right: mq.append(x.right)
            result.append(layer)
        
        return result
```

# N叉树的遍历

## 589.N叉树的前序遍历

[589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

给定一个 n 叉树的根节点  `root` ，返回 _其节点值的 **前序遍历**_ 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

  
**示例 1：**

![[Pasted image 20221226185749.png]]

**输入：** root = [1,null,3,2,4,null,5,6]
**输出：** [1,3,5,6,2,4]

**示例 2：**
![[Pasted image 20221226185811.png]]

**输入：** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
**输出：**[1,2,3,6,7,11,14,4,8,12,5,9,13,10]

**提示：**

-   节点总数在范围 `[0, 104]`内
-   `0 <= Node.val <= 104`
-   n 叉树的高度小于或等于 `1000`

**进阶：** 递归法很简单，你可以使用迭代法完成此题吗?

### 解法

不多说，和二叉树大差不差
- 递归解法
```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        
        if not root: return []
        return self.recursion(root)

    def recursion(self, node):

        result = [node.val]
        for child in node.children:
            result.extend(self.recursion(child))
        
        return result
```
- 迭代解法
```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        
        if not root: return []
        
        stack, result = list(), list()
        stack.append(root)
        
        while(stack):

            x = stack.pop()
            result.append(x.val)
            stack.extend(x.children[::-1])

        return result
```



## 590.N叉树的前序遍历
[590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

给定一个 n 叉树的根节点 `root` ，返回 _其节点值的 **后序遍历**_ 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

**示例 1：**
![[Pasted image 20221226190530.png]]

**输入：** root = [1,null,3,2,4,null,5,6]
**输出：**[5,6,3,2,4,1]

**示例 2：**
![[Pasted image 20221226190546.png]]

**输入：** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
**输出：**[2,6,14,11,7,3,12,8,4,13,9,10,5,1]

**提示：**

-   节点总数在范围 `[0, 104]` 内
-   `0 <= Node.val <= 104`
-   n 叉树的高度小于或等于 `1000`

**进阶：**递归法很简单，你可以使用迭代法完成此题吗?

### 解法

不难实现其递归解法:
```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        
        if not root : return []
        
        return self.post_recursion(root)

    def post_recursion(self, node):

        result = list()
        for child in node.children:
            result.extend(self.post_recursion(child))
        
        result.append(node.val)

        return result
```

考虑二叉树的后序遍历迭代实现方法，可以得到:
```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        
        if not root : return []
        
        stack, result = list(), list()
        stack.append(root)
        
        while(stack):
            x = stack.pop()
            result.append(x.val)
            stack.extend(x.children)

        return result[::-1]
```

## 429.N叉树的层序遍历

给定一个 N 叉树，返回其节点值的_层序遍历_。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

**示例 1：**

![[Pasted image 20221226191642.png]]

**输入：** root = [1,null,3,2,4,null,5,6]
**输出：**` [[1],[3,2,4],[5,6]]`

**示例 2：**

![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

**输入：**root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
**输出：** `[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]`

**提示：**

-   树的高度不会超过 `1000`
-   树的节点总数在 `[0, 10^4]` 之间

### 解法
同二叉树，用队列解决

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        result = list()
        if not root: return result

        from collections import deque

        myq = deque()
        myq.append(root)

        while(myq):
            layer_result = list()
            for _ in range(len(myq)):
                x = myq.popleft()
                layer_result.append(x.val)
                for child in x.children:
                    myq.append(child)
            result.append(layer_result)      

        return result
```


# 226.翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**
![[Pasted image 20221226184408.png]]


**输入：** root = [4,2,7,1,3,6,9]
**输出：** [4,7,2,9,6,3,1]

**示例 2：** 

![[Pasted image 20221226184437.png]]

**输入：** root = [2,1,3]
**输出：** [2,3,1]

**示例 3：**

**输入：** root = []
**输出：** []

**提示：**

-   树中节点数目范围在 `[0, 100]` 内
-   `-100 <= Node.val <= 100`


## 思路

简单画一下，我采用了后序遍历的思路解决这个问题。实际上这题前序和后序都可以做。就是递归里面`swap` 和`recursion` 哪一步先做的区别罢了
```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        if not root : return None
        
        self.recurison(root)

        return root

    def recurison(self, node):

        if node.left: self.recurison(node.left)
        if node.right: self.recurison(node.right)
        node.left, node.right = node.right, node.left

        return
```

# 101. 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**
![[Pasted image 20221226194440.png]]

**输入：** root = [1,2,2,3,4,4,3]
**输出：** true

**示例 2：**
![[Pasted image 20221226194456.png]]

**输入：** root = [1,2,2,null,3,null,3]
**输出：** false

**提示：**

-   树中节点数目在范围 `[1, 1000]` 内
-   `-100 <= Node.val <= 100`

**进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？

## 思路：

- 首先需要想到我们要比较的是根节点的左子树和右子树
- 其次我们要想到比较时是比较两者的里/外节点

递归解法:
```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:

        if not root: return True

        return self.cmp_lr(root.left, root.right)
    
    def cmp_lr(self, left, right):

        if (bool(left) ^ bool(right)): return False
        else:
            if left and right:
                if left.val != right.val: return False
                if not self.cmp_lr(left.left, right.right): return False
                if not self.cmp_lr(left.right, right.left): return False

        return True
```


迭代解法：
这里，通过同一个栈来维护两边
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        st = [] 
        st.append(root.left)
        st.append(root.right)
        while st:
            rightNode = st.pop()
            leftNode = st.pop()
            if not leftNode and not rightNode:
                continue
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            st.append(leftNode.left)
            st.append(rightNode.right)
            st.append(leftNode.right)
            st.append(rightNode.left)
        return True
```


# ==二叉树的深度==

# 104. 二叉树的最大深度
[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**  
给定二叉树 `[3,9,20,null,null,15,7]`，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。

## 思路
#层序遍历
这一题和层次遍历是一个道理，有多少层最大深度就是多少
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root :return 0

        from collections import deque

        myq, layer_count = deque(), 0
        
        myq.append(root)
        while(myq):
            layer_count += 1
            for _ in range(len(myq)):
                x = myq.popleft()
                if x.left: myq.append(x.left)
                if x.right: myq.append(x.right)
        
        return layer_count
```

# 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：** 叶子节点是指没有子节点的节点。

**示例 1：**
![[Pasted image 20221226210137.png]]

**输入：**root = [3,9,20,null,null,15,7]
**输出：**2

**示例 2：**

**输入：**root = [2,null,3,null,4,null,5,null,6]
**输出：**5

**提示：**

-   树中节点数的范围在 `[0, 105]` 内
-   `-1000 <= Node.val <= 1000`


## 思路
#层序遍历
和上一题其实一样，都可以使用层次遍历法，不同的是上一题求最大深度的退出标准是队列为空，而这题的退出标准是队列里存在叶子节点:

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:

        if not root: return 0

        from collections import deque

        myq, minDepth = deque(), 1
        myq.append(root)

        while(myq):
            
            for _ in range(len(myq)):
                node = myq.popleft()
                if (not node.left) and (not node.right): return minDepth
                if node.left: myq.append(node.left)
                if node.right: myq.append(node.right)
            
            minDepth += 1
        
        return minDept
```


# 222.完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

**示例 1：**
![[Pasted image 20221227155828.png]]

**输入：** root = [1,2,3,4,5,6]
**输出：** 6

**示例 2：**

**输入：** root = []
**输出：** 0

**示例 3：**

**输入：** root = [1]
**输出：** 1

**提示：**

-   树中节点的数目范围是`[0, 5 * 104]`
-   `0 <= Node.val <= 5 * 104`
-   题目数据保证输入的树是 **完全二叉树**

## 思路
#层序遍历
可以使用层次遍历的方法，当遍历完当前层发现队列长度小于应该`2**n`时，可以退出
```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:

        if not root: return 0

        from collections import deque

        myq, layer = deque(), 0
        myq.append(root)

        while(myq):
            layer += 1
            for _ in range(len(myq)):
                x = myq.popleft()
                if x.left: myq.append(x.left)
                if x.right: myq.append(x.right)

            if len(myq) < 2**layer: return 2**layer-1+len(myq)
        
        return 2**layer-1
```

可以考虑完全二叉树的性质：
- 叶子节点全部集中在左边
- 当一棵完全二叉树的最左深度和最右深度相同时，该树是满二叉树

我们可以判断某个节点的最左深度和最右深度是否相同
- 相同：是一棵满二叉树，因此该树的节点数为`2**depth-1`
- 不同：该二叉树为左子树和右子树节点和+1

于是可以写出这样的递归代码:
```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:

        if not root: return 0
        
        left, right = root.left, root.right
        left_depth, right_depth = 0, 0
        
        while(left):
            left_depth += 1
            left = left.left
        
        while(right):
            right_depth += 1
            right = right.right
        
        if left_depth == right_depth: return 2**(left_depth+1) - 1

        return 1+self.countNodes(root.left)+self.countNodes(root.right)
            
```


# 110.平衡二叉树
[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：**
![[Pasted image 20221227164143.png]]

**输入：** root = [3,9,20,null,null,15,7]
**输出：** true

**示例 2：**
![[Pasted image 20221227164154.png]]

**输入：** root = [1,2,2,3,3,null,null,4,4]
**输出：** false

**示例 3：**

**输入：** root = []
**输出：** true

**提示：**

-   树中的节点数在范围 `[0, 5000]` 内
-   `-104 <= Node.val <= 104`


## 思路

- 递归解法
由于实际上要判断左子树深度和右子树深度之差是否为小于1，所以应该是后序遍历。
问题是递归函数返回什么：
- 平衡的时候，我们应该返回左右子树的最大树深度+1(因为还有你的根节点)
- 不平衡的时候，我们应该返回`-1` ，该标志说明了遇到不平衡情况，请求前序函数同样返回`-1`指示停止整个递归过程

可以写出:
```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        return (True if self.recursion(root) != -1 else False)
    
    def recursion(self, root):
        
        if not root: return 0

        left_depth = self.recursion(root.left)
        if left_depth == -1: return -1
        
        right_depth = self.recursion(root.right)
        if right_depth == -1: return -1

        if abs(left_depth - right_depth) > 1:return -1
        
        return max(left_depth, right_depth)+1
```

# ==路径类题== 
# 257.二叉树的所有路径
[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)
给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**
![[Pasted image 20221230152037.png]]

**输入：** root = [1,2,3,null,5]
**输出：** ["1->2->5","1->3"]

**示例 2：**

**输入：** root = [1]
**输出：**["1"]

**提示：**

-   树中节点的数目在范围 `[1, 100]` 内
-   `-100 <= Node.val <= 100`

## 思路
- 递归解法：
  主要是如何设计递归函数，即传什么参数、返回什么。
  - 传参：应该涉及前序路径，所以传递的参数包含之前走过的节点的列表
  - 返回：应该返回该节点下所有叶子节点的从根节点到叶子节点的完整路径

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        
        return ['->'.join(i) for i in self.recursion(root, list())]
    
    def recursion(self, root, pre_route):

        result = list()
        new_route = pre_route.copy()
        new_route.append(str(root.val))

        if root.left: result.extend(self.recursion(root.left, new_route))
        if root.right: result.extend(self.recursion(root.right, new_route))

        if (not root.left) and (not root.right): result = [new_route]
        
        return result
```

- 迭代解法
  问题是如何从遍历中保存到当前节点的路径，可以设计两个栈
  - 遍历栈： 跟前序遍历时的差不多，该栈保存待遍历的节点
  - 路径栈：该同样操作，但保存的是到待走节点的完整路径
  - 在实际运行中，遍历栈和路径栈操作应该同步，两个一起append或pop，这样保证了两者内部元素一一对应，前者元素是准备要遍历的节点，后者元素是到该节点的路径。pop时前者出一个节点，而后者出的是到这个节点的路径。append时前者是加入某个节点，后者是当前路径连接该节点的完整路径。
  - 结束判据是遍历栈或路径栈空（因为两者一样）
```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        
        result, stack, path = list(), list(), list()
        
        stack.append(root)
        path.append(str(root.val))

        while(stack):
            x = stack.pop()
            cur_path = path.pop()
            if (not x.left) and (not x.right):
                result.append(cur_path)
                continue
            if x.right:
                stack.append(x.right)
                path.append(cur_path+'->'+str(x.right.val))
            if x.left:
                stack.append(x.left)
                path.append(cur_path+'->'+str(x.left.val))
        
        return result
```

# 404.左叶子之和
[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**
![[Pasted image 20221230162746.png]]


**输入:** root = [3,9,20,null,null,15,7] 
**输出:** 24 
**解释:** 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

**示例 2:**

**输入:** root = [1]
**输出:** 0

**提示:**

-   节点数在 `[1, 1000]` 范围内
-   `-1000 <= Node.val <= 1000`

## 思路
这道题的问题在于不能直接通过当前节点判断自己是不是左叶子，所以要依靠父节点。那我可以从父节点判断其左左子是不是叶子节点，也可以根据一个叶子节点判断它是不是左子。
从程序运行方法上看，似乎迭代适合从父节点判断左子节点是不是叶子节点，而递归都可以，因为传参的时候可以把子节点是左还是右传进去。

- 迭代解法
  因为我感觉迭代也可以判断左叶子，所以可以用。这里的做法是经典前序遍历的写法稍加改变，一个节点的右子无需判断它是不是叶子节点，而左子才需要判断。当左子是叶子节点时，就不用append了，直接加到结果里面就行。

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        result = 0
        if (not root.left) and not(root.right): return result

        stack = [root]

        while(stack):

            x = stack.pop()

            if x.right:
                stack.append(x.right)
            if x.left:
                if (not x.left.left) and (not x.left.right): 
                    result += x.left.val
                    continue
                stack.append(x.left)
        
        return result
```


# 513.找树左下角的值

[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1:**
![[Pasted image 20221230170047.png]]


**输入:** root = [2,1,3]
**输出:** 1

**示例 2:**
![[Pasted image 20221230170055.png]]

**输入:** [1,2,3,4,null,5,6,null,null,7]
**输出:** 7

**提示:**

-   二叉树的节点个数的范围是 `[1,104]`
-   `-231 <= Node.val <= 231 - 1`



## 思路

- 直接层序遍历，结果更新为队列第一个即可

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:

        from collections import deque

        myq = deque()
        myq.append(root)
        mostleft = None
        while(myq):

            mostleft = myq[0].val
            for _ in range(len(myq)):
                x = myq.popleft()
                if x.left: myq.append(x.left)
                if x.right: myq.append(x.right)
        
        return mostleft
```


# 112.路径总和

[力扣题目链接](https://leetcode.cn/problems/path-sum/)
#二叉树路径
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**
![[Pasted image 20230103144149.png]]

**输入：** root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
**输出：** true
**解释：** 等于目标和的根节点到叶节点路径如上图所示。

**示例 2：**
![[Pasted image 20230103144200.png]]

**输入：** root = [1,2,3], targetSum = 5
**输出：** false
**解释：** 树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。

**示例 3：**

**输入：** root = [], targetSum = 0
**输出：** false
**解释：** 由于树是空的，所以不存在根节点到叶子节点的路径。

**提示：**

-   树中节点的数目在范围 `[0, 5000]` 内
-   `-1000 <= Node.val <= 1000`
-   `-1000 <= targetSum <= 1000`


## 思路

- 迭代：
  考虑之前那道[二叉树的所有路径](#257.二叉树的所有路径) ，用一个栈维护待遍历的节点，一个栈维护走到对应节点的路径。这道题把后者改成储存走到该节点的求和即可，在到达叶子节点的时候判断当前节点的求和是否等于`target_sum` 即可。

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        if not root:  return False

        calc_sum = 0
        vis_stack = [root]
        sum_stack = [root.val]

        while(vis_stack):

            x = vis_stack.pop()
            x_sum = sum_stack.pop() 
            
            if (not x.left) and (not x.right):
                if x_sum == targetSum: return True
            
            if x.right:
                vis_stack.append(x.right)
                sum_stack.append(x_sum + x.right.val)
            
            if x.left:
                vis_stack.append(x.left)
                sum_stack.append(x_sum + x.left.val)
        
        return False
```


- 由于递归版本是需要层层返回结果，因此我这里就选了迭代写法

# 113.路径总和II
[力扣题目连接](https://leetcode.cn/problems/path-sum-ii/description/)
#二叉树路径
给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**
![[Pasted image 20230103144935.png]]


**输入：** root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
**输出：**[[5,4,11,2],[5,8,4,5]]

**示例 2：**
![[Pasted image 20230103145015.png]]

**输入：** root = [1,2,3], targetSum = 5
**输出：**[]

**示例 3：**

**输入：** root = [1,2], targetSum = 0
**输出：**[]

**提示：**

-   树中节点总数在范围 `[0, 5000]` 内
-   `-1000 <= Node.val <= 1000`
-   `-1000 <= targetSum <= 1000`

## 思路

- 这道题可以选迭代解法，也可以选递归解法
- 迭代解法与上一题[112.路径总和](#112.路径总和) 相同，一个栈维护待遍历节点，另一个栈维护到对应节点的路径和路径上的和。
- 刚开始我想的是用`x_sum.copy()` 来创建二号栈的入栈对象，但发现会导致错误，因为该方法返回的实际上是一个浅拷贝对象，会被多次修改。要

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        if not root:  return []

        calc_sum = 0
        result = []
        vis_stack = [root]
        sum_stack = [[[root.val],root.val]]

        while(vis_stack):
            
            #print(sum_stack)
            x = vis_stack.pop()
            x_sum = sum_stack.pop() 
            
            if (not x.left) and (not x.right):
                if x_sum[1] == targetSum: result.append(x_sum[0])
            
            if x.right:
                vis_stack.append(x.right)
                sum_stack.append([x_sum[0]+[x.right.val], x_sum[1]+ x.right.val])
            
            if x.left:
                vis_stack.append(x.left)
                sum_stack.append([x_sum[0]+[x.left.val], x_sum[1]+ x.left.val])
        
        return result
```

# ==构造二叉树== 
# 106.从中序与后序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
#构建二叉树 
给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。

**示例 1:**
![[Pasted image 20230103200848.png]]

**输入：** inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
**输出：**[3,9,20,null,null,15,7]

**示例 2:**

**输入：** inorder = [-1], postorder = [-1]
**输出：** [-1]


## 思路

首先需要注意的是中序遍历的是 左-中-右，后序遍历的是 左-右-中
然而我们构造二叉树一般先确定根节点的值，再确认左右子树

那找到每个子树的中节点就比较重要了：
- 显然，后序遍历的最后一个就是根节点。
- 通过上面得到的根节点可以在中序遍历里面划分左子树组成和右子树组成。
- 通过上面得到的根节点位置可以确定后序遍历的左子树部分(考虑无论是中序还是后序，左子树里面元素的个数都是一样的)和右子树部分

就可以通过递归解法构造二叉树:
- 递归函数接受子树的中序遍历及后序遍历序列
- 当遍历序列为空时，说明该子树纯空，应该返回`None`
- 当遍历序列长度为1时，说明该子树为叶子节点，直接返回`TreeNode(root.val)`
- 当遍历序列长度大于1时，说明该子树不为叶子节点，此时应该为中序遍历及后序遍历划分左子树和右子树的区间
- 对左右子树进行递归
- 递归返回值是接受两个序列而产生的子树根节点

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:

        if (not inorder): return None

        root = TreeNode(postorder[-1])
        if len(inorder) == 1: return root

        split = inorder.index(root.val)

        left_inorder, right_inorder = inorder[:split], inorder[split+1:]
        left_postorder, right_postorder = postorder[:split], postorder[split:-1]

        root.left = self.buildTree(left_inorder, left_postorder)
        root.right = self.buildTree(right_inorder, right_postorder)

        return root
```

- 这一题由于我没有用那个`split` 变量暂存查找的中间节点位置，造成大量时间浪费，改了以后好点
- 这个方法的问题在于空间占用率高，因为每次传参都是两个硬拷贝对象

更好的方法：还没看懂
```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:

        def build(left, right):

            if left > right: return None

            root_val = postorder.pop()
            split = inorder.index(root_val)
            root = TreeNode(root_val)
            root.right = build(split+1, right)
            root.left = build(left, split-1)

            return root

        

        return build(0, len(inorder)-1)
```


# 105.从前序和中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![[Pasted image 20230104153255.png]]

**输入**:  preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
**输出:** [3,9,20,null,null,15,7]

**示例 2:**

**输入:** preorder = [-1], inorder = [-1]
**输出:** [-1]

**提示:**

-   `1 <= preorder.length <= 3000`
-   `inorder.length == preorder.length`
-   `-3000 <= preorder[i], inorder[i] <= 3000`
-   `preorder` 和 `inorder` 均 **无重复** 元素
-   `inorder` 均出现在 `preorder`
-   `preorder` **保证** 为二叉树的前序遍历序列
-   `inorder` **保证** 为二叉树的中序遍历序列


## 思路

和上一题是一样的
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:

        if not preorder: return None
        root_val = preorder[0]
        root = TreeNode(root_val)
        
        
        if len(preorder) == 1: return root

        split = inorder.index(root_val)
        root.left = self.buildTree(preorder[1:split+1], inorder[:split])
        root.right = self.buildTree(preorder[split+1:], inorder[split+1:])


        return root
```


# 654.最大二叉树

[力扣题目地址](https://leetcode.cn/problems/maximum-binary-tree/)
#构建二叉树
给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1.  创建一个根节点，其值为 `nums` 中的最大值。
2.  递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3.  递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 _`nums` 构建的_ **_最大二叉树_** 。

**示例 1：**
![[Pasted image 20230104152503.png]]

**输入：** nums = [3,2,1,6,0,5]
**输出：** [6,3,5,null,2,0,null,null,1]
**解释：** 递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。

**示例 2：**
![[Pasted image 20230104152525.png]]


**输入：** nums = [3,2,1]
**输出：**[3,null,2,null,1]

**提示：**

-   `1 <= nums.length <= 1000`
-   `0 <= nums[i] <= 1000`
-   `nums` 中的所有整数 **互不相同**

## 思路

可以按照它给出的算法来组建递归表达式
- 递归的输入是需要构造的列表，根据该列表可以返回从列表构建的二叉树的根节点
- 特别情况：
  - 当传入的列表为空的时候终止接下来的递归，返回None
  - 当传入的列表仅一个数时，返回里面唯一一个值构成的树节点
- 找到最大值的位置，并分割

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:

        if not nums: return None
        if len(nums) == 1: return TreeNode(nums[0])

        val_max , max_index = -1, 0
        for i, x in enumerate(nums):
            if x > val_max:
                val_max , max_index = x, i
        
        root = TreeNode(val_max, 
                        left = self.constructMaximumBinaryTree(nums[:max_index]), 
                        right= self.constructMaximumBinaryTree(nums[max_index+1:]))
        


        return root
```

- 另一个方法是递归参数使用数组区间，我这里控制的区间设置是左闭右开区间`[left,right)`
```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:


        def recursion(left, right):
            if left == right: return None
            
            val_max , max_index = -1, 0
            for i in range(left, right):
                if nums[i] > val_max:
                    val_max , max_index = nums[i], i
            
            root = TreeNode(val_max, 
                            left = recursion(left, max_index),
                            right = recursion(max_index+1, right))

            return root
        
        return recursion(0, len(nums))
```
- 然而这个操作要比前者慢，空间占用也更大 这我不是很懂。



# 617.合并二叉树
[力扣题目链接](https://leetcode.cn/problems/merge-two-binary-trees/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**
![[Pasted image 20230104155944.png]]

**输入：** root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
**输出：** [3,4,5,5,4,null,7]

**示例 2：**

**输入：** root1 = [1], root2 = [1,2]
**输出：**[2,2]

**提示：**

-   两棵树中的节点数目在范围 `[0, 2000]` 内
-   `-104 <= Node.val <= 104`


## 思路

还是用递归的方式解决。
- 递归的参数接受 **拓扑位置相同的** 树1的树节点和树2的树节点
- 递归返回按照给出节点合并的根节点结果
- 特别情况：
  - 当树1的节点为空时，说明接下来不用合并了，返回树2节点即可
  - 当树2的节点为空时，说明接下来不用合并了，返回树1节点即可
  - 当树1、2节点都为空时，说明同时到达叶子节点，返回none
- 新建一个树节点root保存root1.val+root2.val
- root.left及root.right调用递归

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        
        if not root1: return root2
        if not root2: return root1
        if (not root1) and (not root2): return None

        root = TreeNode(root1.val+root2.val)
        root.left = self.mergeTrees(root1.left, root2.left)
        root.right = self.mergeTrees(root1.right, root2.right)
        
        return root
```

# ==二叉搜索树BST==

# 700.二叉搜索树中的搜索

[力扣题目地址](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例 1:**
![[Pasted image 20230104162358.png]]

**输入：** root = [4,2,7,1,3], val = 2
**输出：**[2,1,3]

**示例 2:**
![[Pasted image 20230104162408.png]]


**输入：** root = [4,2,7,1,3], val = 5
**输出：** []

**提示：**

-   数中节点数在 `[1, 5000]` 范围内
-   `1 <= Node.val <= 107`
-   `root` 是二叉搜索树
-   `1 <= val <= 107`

## 思路

#二叉搜索树 满足这样的要求：
- 对于树的任意子树都有：
  - 左子树所有元素小于根节点
  - 右子树所有元素大于根节点

不难写出：
```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:

        cur = root

        while(cur):
            if val == cur.val: return cur
            if val < cur.val : 
                cur = cur.left
                continue
            if val > cur.val:
                cur = cur.right

        return None
```


# 98.验证二叉搜索树
[力扣题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

-   节点的左子树只包含 **小于** 当前节点的数。
-   节点的右子树只包含 **大于** 当前节点的数。
-   所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**
![[Pasted image 20230104170520.png]]

**输入：** root = [2,1,3]
**输出：** true

**示例 2：**
![[Pasted image 20230104170535.png]]

**输入：** root = [5,1,4,null,null,3,6]
**输出：** false
**解释：** 根节点的值是 5 ，但是右子节点的值是 4 。

**提示：**

-   树中节点数目范围在`[1, 104]` 内
-   `-231 <= Node.val <= 231 - 1`

## 思路

- 这道题我刚开始想到的是递归方法，比较根节点和左右子是否按序排
- 出现问题，因为左子虽然小于根节点，但左子的右子可能大于根节点！注意搜索二叉树的定义，他要求左子树所有要小于根节点小于右子树所有节点
- 无奈，我这里使用的是递归函数返回该节点下的最小值、最大值、该节点是否构成搜索二叉树

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        
        def recursion(root):

            new_min, new_max = root.val, root.val

            if root.left: 
                left_min, left_max, left_isBST = recursion(root.left)
                if (not left_isBST) or left_max >= root.val: return 0.0, 0.0, False
                new_min = left_min
            
            if root.right:
                right_min, right_max, right_isBST = recursion(root.right)
                if (not right_isBST) or right_min <= root.val: return 0.0, 0.0, False
                new_max = right_max
            
            return new_min, new_max, True
        
        return recursion(root)[2]
```

- 另一种做法是使用中序遍历，然后逐一比较前值和后值大小。因为中序遍历刚好就是（左-中-右）的顺序
- 这里的中序遍历可以用迭代也可以用递归实现，写了个迭代的

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        
        cur, stack = root, []
        last = - 2**32
        while(cur or stack):
            
            if cur: 
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if last >= cur.val: 
                    return False
                else: 
                    last = cur.val
                cur = cur.right

        return True
```

# 530.二叉搜索树的最小绝对差

[力扣题目链接](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例 1：**
![[Pasted image 20230105151504.png]]


**输入：** root = [4,2,6,1,3]
**输出：** 1

**示例 2：**
![[Pasted image 20230105151514.png]]

**输入：**root = [1,0,48,null,null,12,49]
**输出：**1

**提示：**

-   树中节点的数目范围是 `[2, 104]`
-   `0 <= Node.val <= 105`


## 思路
这道题和上一道比较相似，实际上我们需要计算二叉搜索树值相邻的两个数的差。上一题我们要验证的是前值小于后值，而这道题我们是对比相邻两数的绝对差和已有的最小绝对差。
按照这个想法，我们可以写一个中序遍历的方法完成任务

```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:

        stack = list()
        last, min_diff = 2**15, 2**15
        cur = root

        while(cur or stack):
            if cur:
                stack.append(cur)
                cur = cur.left
            
            else:
                cur = stack.pop()
                new_diff = abs(cur.val-last)
                if new_diff < min_diff: min_diff = new_diff
                last = cur.val

                cur = cur.right
        
        return min_diff
```


# 501.二叉搜索树中的众数

[力扣题目链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

-   结点左子树中所含节点的值 **小于等于** 当前节点的值
-   结点右子树中所含节点的值 **大于等于** 当前节点的值
-   左子树和右子树都是二叉搜索树

**示例 1：**
![[Pasted image 20230105154859.png]]

**输入：** root = [1,null,2,2]
**输出：** [2]

**示例 2：**

**输入：** root = [0]
**输出：** [0]

**提示：**

-   树中节点的数目在范围 `[1, 104]` 内
-   `-105 <= Node.val <= 105`

**进阶：** 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）


## 思路
- 依旧要使用中序遍历，因为这样可以把值相等的数放到一起
- 用一个变量保存上一个计数对象，另一个保存上一个计数对象的计数数
- 当新的`cur` 和上一个计数对象相同的时候就`cur_count +=1 `否则初始化
- 当`cur_count == max_count` 时将`cur_val`append进结果
- 当`cur_count > max_count` 时将`cur_val`当成唯一结果

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:

        stack = list()
        cur = root
        result, max_count = [], 0
        cur_val, cur_count = None, 0

        while(cur or stack):
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if cur.val == cur_val:
                    cur_count += 1
                else: 
                    cur_val, cur_count = cur.val, 1
                
                if cur_count == max_count:
                    result.append(cur_val)

                if cur_count > max_count: 
                    max_count = cur_count
                    result = [cur_val]

                cur = cur.right
        
        return result
```

# 236.二叉树的最近公共祖先


[力扣题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**
![[Pasted image 20230110014422.png]]

**输入：** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
**输出：** 3
**解释：** 节点 `5` 和节点 `1` 的最近公共祖先是节点 `3 。`

**示例 2：**
![[Pasted image 20230110014459.png]]

**输入：** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
**输出：** 5
**解释：** 节点 `5` 和节点 `4` 的最近公共祖先是节点 `5 。`因为根据定义最近公共祖先节点可以为节点本身。

**示例 3：**

**输入：** root = [1,2], p = 1, q = 2
**输出：** 1



## 思路

- 如果我们可以自下往上寻找的话应该会比较好找到公共祖先，问题是常规思路或者是说我对二叉树的理解是至上而下构建的，那问题在于找到一种可以自下往上的遍历方式
- 实际上后序遍历就能实现自下而上的遍历，因为其顺序是左-右-中
- 解决了遍历方式以后，该考虑如何找到公共节点：
  - 如果我用递归，那首先要确定返回的是什么
  - 我希望当前节点的返回值应该包含在该节点以下的符合条件的节点，这样我就可以比较左右中三者的返回值是能在其中获得所有节点

- 递归解法：
  - 后序遍历
  - 返回值为该节点下为查找p或q的结果
  - 当找到一个，就往里面extend
  - 当结果列表里面有两个的时候就可以把当前节点写进去了


```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        bingo = (p.val, q.val)

        def recursion(node):
            
            check_list = []
            if node.left: check_list.extend(recursion(node.left))
            if node.right: check_list.extend(recursion(node.right))

            if node.val in bingo:
                check_list.append(node)
            
            if len(check_list) == 2:
                check_list.append(node)

            return check_list

        return recursion(root)[-1]
```


# 235.二叉搜索树的最近公共祖先

[力扣题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
![[Pasted image 20230110122804.png]]

**示例 1:**

**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
**输出:** 6 
**解释:** 节点 `2` 和节点 `8` 的最近公共祖先是 `6。`

**示例 2:**

**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
**输出:** 2
**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。

**说明:**

-   所有节点的值都是唯一的。
-   p、q 为不同节点且均存在于给定的二叉搜索树中。


## 思路

- 考虑二叉搜索树的特点： 
  - 所有左子树中的节点均小于当前根节点
  - 所有右子树中的节点均大于当前根节点
- 对于两个不同的树节点：
  - 如果p和q都小于该节点，那说明两者都在该节点左边
  - 如果p和q都大于该节点，那说明两者都在该节点右边
  - 如果p和q其中一个等于该节点，无论剩下那个比他大还是比他小，按照二叉搜索树性质都必有剩下那个是当前节点的子树，那显然当前节点就是所求节点
  - 如果p和q一个大于该节点一个小于该节点，那显然当前节点就是所求节点

直接迭代解法:


```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        cur = root
        while(True):
            if p.val < cur.val and q.val < cur.val: cur = cur.left
            elif p.val > cur.val and q.val > cur.val: cur = cur.right
            else: return cur
```

# 701.二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例 1：**

![[Pasted image 20230110131848.png]]

**输入：** root = [4,2,7,1,3], val = 5
**输出：**[4,2,7,1,3,5]
**解释：** 另一个满足题目要求可以通过的树是：

![[Pasted image 20230110131858.png]]
**示例 2：**

**输入：** root = [40,20,60,10,30,50,70], val = 25
**输出：** [40,20,60,10,30,50,70,null,null,25]

**示例 3：**

**输入：** root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
**输出：** [4,2,7,1,3,5]

**提示：**

-   树中的节点数将在 `[0, 104]`的范围内。
-   `-108 <= Node.val <= 108`
-   所有值 `Node.val` 是 **独一无二** 的。
-   `-108 <= val <= 108`
-   **保证** `val` 在原始BST中不存在。

## 思路

- 这题和上一题有点像，我们需要利用BST的特性寻找插入位置
- 问题是如何设置插入规则，我有这些考虑：
  - 尽可能只改一个节点的链接，这样可以极大地减少修改成本
	- 如果从非叶子节点处修改，可能面临一些问题：
	    - 考虑序列[5,4.5,None,None, 4.9]插入4.7，如果要在5-4.5处断链修改，我们必须判断4.5右子树所有值均小于4.7，这将带来麻烦
	- 如果新插入的节点是一个叶子节点，以上问题迎刃而解，根本不需要考虑比较其父节点的所有子树元素与待插入节点的关系
- 技术上，如果我们要处理一个链式结构，而链表头可能会修改，那可以考虑使用虚拟节点（然而实际上没有用到，因为这里不会修改根节点，而是只改叶子节点）

> ==指导：==
> 首先在二叉搜索树中的插入操作，大家不用恐惧其重构搜索树，其实根本不用重构。
```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        dummy_node = TreeNode(2**31, root)
        pre, cur = dummy_node, root

        while(cur):
            if cur.val < val: 
                pre, cur = cur, cur.right
            else: 
                pre, cur = cur, cur.left
        
        if val < pre.val: pre.left =  TreeNode(val)
        else: pre.right = TreeNode(val)

        return dummy_node.left
```



# 450.删除二叉搜索树中的节点

[力扣题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1.  首先找到需要删除的节点；
2.  如果找到了，删除它。

**示例 1:**

![[Pasted image 20230111202111.png]]

**输入：** root = [5,3,6,2,4,null,7], key = 3
**输出：** [5,4,6,2,null,null,7]
**解释：** 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
![[Pasted image 20230111202121.png]]


**示例 2:**

**输入:** root = [5,3,6,2,4,null,7], key = 0
**输出:** [5,3,6,2,4,null,7]
**解释:** 二叉树不包含值为 0 的节点

**示例 3:**

**输入:** root = [], key = 0
**输出:** []

**提示:**

-   节点数的范围 `[0, 104]`.
-   `-105 <= Node.val <= 105`
-   节点值唯一
-   `root` 是合法的二叉搜索树
-   `-105 <= key <= 105`

**进阶：** 要求算法时间复杂度为 O(h)，h 为树的高度。



## 思路
---
### 迭代
- 和传统的删除有链结构一样，可以引入虚拟头节点来解决可能删除链头问题
- 由于使用的是二叉搜索树，寻找删除节点可以直接使用迭代方法
- 删除的节点主要有两种情况：
  - 该节点为叶子节点，那么其父节点只要去除链接即可
  - 该节点非叶子节点：
    - 只有一个子树： 则将子树向上移动即可
    - 有两个子树：
      - 找出左子树的最大值，把右子树移过去
      - 找出右子树的最小值，把左子树移过去


不难写出：

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:

        dummy = TreeNode(2**31, root)
        pre, cur = dummy, root
        flag = False
        while(cur):
            if key < cur.val: 
                pre, cur = cur, cur.left
            elif key > cur.val:
                pre, cur = cur, cur.right
            else:
                flag = True
                break
        if flag == False: return dummy.left

        if (not cur.left) and (not cur.right): 
            if pre.val > cur.val: pre.left = None
            if pre.val < cur.val: pre.right = None

            return dummy.left

        if cur.left and cur.right:  

            left_leaf = cur.left
            while(left_leaf):
                if left_leaf.right: left_leaf = left_leaf.right
                else: break
            
            left_leaf.right = cur.right
            if pre.val > cur.val: pre.left = cur.left
            if pre.val < cur.val: pre.right = cur.left
            return dummy.left

        x = cur.left if cur.left else cur.right
        if pre.val > cur.val: pre.left = x
        if pre.val < cur.val: pre.right = x

        return dummy.left
```

### 递归
- 受[669.修建二叉搜索树](#669.修建二叉搜索树) 启发，BST的增删查改实际也可以用递归来解决：
	- 当目标节点大于当前根节点时，我们可以仅递归操作右子树
	- 当目标节点小于当前根节点时，我们可以仅递归操作左子树
	- 当目标节点等于当前节点时，我们可以针对修改写一套逻辑

- 这一题，同样，首先判断输入节点，空时返回空
- 当当前节点不是删除目标时：判断其大小好决定递归修改哪一边子树
- 当当前节点是删除目标时：
  - 如果左子树存在就把右子树接到左子树最大值的右边， 然后返回左子树根节点即可
  - 如果左子树不存在的化直接返回右子树即可（这里就是直接把当前节点是叶子节点的情况也处理了）


```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        
        if not root: return None

        if root.val != key:
            if root.val < key:
                root.right = self.deleteNode(root.right, key)
            if key < root.val:
                root.left = self.deleteNode(root.left, key)
            
            return root
         
        if root.left:
            cur = root.left
            while(cur.right):
                cur = cur.right
            cur.right = root.right

            return root.left
        
        return root.right
        
```

# 669.修建二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例 1：**
![[Pasted image 20230111211838.png]]

**输入：** root = [1,0,2], low = 1, high = 2
**输出：** [1,null,2]

**示例 2：**
![[Pasted image 20230111211846.png]]
**输入：** root = [3,0,4,null,2,null,null,1], low = 1, high = 3
**输出：** [3,2,null,1]

**提示：**

-   树中节点数在范围 `[1, 104]` 内
-   `0 <= Node.val <= 104`
-   树中每个节点的值都是 **唯一** 的
-   题目数据保证输入是一棵有效的二叉搜索树
-   `0 <= low <= high <= 104`


## 思路

- 像往常一样，我本来的想法是针对BST使用迭代算法，但稍加思考，我发现了其中的难点：
  - 如果像样例中那样，我需要寻找一个尽可能小的大于low的节点，把它拼接在比他大一点的节点上，显然为了这个操作我必须保存一部分我遍历过的节点。那可能我就要使用类似于栈类的数据结构
  - 另外，上一个操作要做两次，查找比尽可能大的比high小的节点
  - 我们还需要考虑当我们需要删除头节点的时候怎么办

- 总而言之，我发现这个使用迭代的方法完成这个问题似乎稍微困难，于是我接下来尝试使用递归方法

### 递归
---
1.  我思考的第一个问题是：如果给出的根节点不在区间范围内，我该怎么处理。稍加思索我发现，作为递归函数，此时我应该返回使用trimBST处理其可能落在该区间内的子树集合，即：
  - 当root.val < low时， 可能落在目标区间内的子树应该是root.right的内容，因此直接返回trimBST(root.right)
  - 当root.val > high时， 可能落在目标区间内的子树应该是root.left的内容，因此直接返回trimBST(root.left)

2. 接下来，如果root.val 是落在目标区间内的，那我该怎么处理。稍加思索，我发现其左右子树应该是修剪后的左右子树，保证该子树内所有内容符合要求。
   - 这里可以发现，接下来设计递归程序的时候，其返回值应该是一所有节点均落在区间内的BST的根节点。
   - 因此, root.left = trimBST(root.left) 及root.right = trimBST(root.right)

3. 可以确定递归函数，因为题目要求和递归函数的返回值要求一致，而要求的参数也一致，因此没有必要另写一个递归函数：
   - 输入参数是当前根节点及区间
   - 返回修建好的子树
   - 另外需要考虑的是如果root是一个空的，或者在递归过程中走到了叶子节点的左右子树，因此可以在程序头写一个判断root是否存在的if


可以写出：
```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        
        if not root: return None

        if root.val < low:
            return self.trimBST(root.right, low, high)      
        if root.val > high:
            return self.trimBST(root.left, low, high)

        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        
        return root
```



# 108.将有序数组转换为二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

**输入：** nums = [-10,-3,0,5,9]
**输出：** [0,-3,9,-10,null,5]
**解释：** [0,-10,5,null,-3,null,9] 也将被视为正确答案：
![](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

**输入：** nums = [1,3]
**输出：** [3,1]
**解释：** [1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。

**提示：**

-   `1 <= nums.length <= 104`
-   `-104 <= nums[i] <= 104`
-   `nums` 按 **严格递增** 顺序排列

## 思路

- 这一道题不难，因为给出的是一个有序数组，而且要求是二叉平衡搜索树，那我每次都把数组划分成元素数量差不超过1的两个数组和一个根节点，进行递归构建即可

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        
        size = len(nums)
        if size == 0: return None
        
        root = TreeNode(nums[size//2])
        root.left =  self.sortedArrayToBST(nums[:size//2])
        root.right = self.sortedArrayToBST(nums[size//2+1:])

        return root
```



# 538.把二叉搜索树转换为累加树

[力扣题目链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

-   节点的左子树仅包含键 **小于** 节点键的节点。
-   节点的右子树仅包含键 **大于** 节点键的节点。
-   左右子树也必须是二叉搜索树。

**注意：** 本题和 1038: [https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 相同

**示例 1：**



**输入：**[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
**输出：**[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

**示例 2：**

**输入：** root = [0,null,1]
**输出：** [1,null,1]

**示例 3：**

**输入：** root = [1,0,2]
**输出：** [3,3,2]

**示例 4：**

**输入：** root = [3,2,4,1]
**输出：** [7,9,4,10]

**提示：**

-   树中的节点数介于 `0` 和 `104` 之间。
-   每个节点的值介于 `-104` 和 `104` 之间。
-   树中的所有值 **互不相同** 。
-   给定的树为二叉搜索树。

## 思路

- BST使用中序遍历可以得到从小到大的排列，即左-中-右排列。沿着这个思路，如果我们可以从大到小遍历BST，并累加遍历过的值，那处理过程应该非常直观。
- 使用一种反过来的中序遍历实现右-中-左遍历，并使用迭代处理遍历过程。之所以不用递归，主要是没有想到如何去判断递归到了最大值处，以及传参及递归过程处理左子树时较为麻烦


```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        
        bigger_sum  = 0
        
        cur, stack = root, list()
        
        while(cur or stack):
            
            if cur: 
                stack.append(cur)
                cur = cur.right
            else:
                cur = stack.pop()
                cur.val += bigger_sum
                bigger_sum = cur.val
                cur = cur.left
        
        return root
```

