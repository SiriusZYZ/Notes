#leetcode100 #难题 #不熟

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

**示例 1：**

**输入：**`nums = [1,3,-1,-3,5,3,6,7], k = 3`
**输出：**`[3,3,5,5,6,7]`
**解释：**
```
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

**输入：**`nums = [1], k = 1`
**输出：**`[1]`

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

## 思路

- 构造一个优先队列：
>单调队列真是一种让人感到五味杂陈的数据结构，它的维护过程更是如此.....就拿此题来说，队头最大，往队尾方向单调......**有机会站在队头的老大永远心狠手辣**，当它从队尾杀进去的时候，**如果它发现这里面没一个够自己打的，它会毫无人性地屠城，把原先队里的人头全部丢出去**，转身建立起自己的政权，野心勃勃地准备开创一个新的王朝.....这时候，它的人格竟发生了一百八十度大反转，它变成了一位胸怀宽广的慈父！**它热情地请那些新来的“小个子”们入住自己的王国**......然而，**这些小个子似乎天性都是一样的——嫉妒心强，倘若见到比自己还小的居然更早入住王国，它们会心狠手辣地找一个夜晚把它们通通干掉，好让自己享受更大的“蛋糕”；当然，遇到比自己强大的，它们也没辙，乖乖夹起尾巴做人。** 像这样的暗杀事件每天都在上演，虽然王国里日益笼罩上白色恐怖，但是好在没有后来者强大到足以干翻国王，江山还算能稳住。直到有一天，闯进来了一位真正厉害的角色，就像当年打江山的国王一样，手段狠辣，野心膨胀，于是又是大屠城......历史总是轮回的。

- 为什么新来的可以屠城：
  因为它排在已有的队列中所有已有数字的后面，只要新来的比他们大，之前的就永远不可能成为窗口内的最大值。
- 为什么队头是最大值：
  因为比它大的而且是后来出现的都把它消灭了
- 当一个数离开窗口时该怎么做：
  如果它是最大值，那应该先把它给删了
  如果它不是最大值，其实可以不管，因为它早已被历史所掩埋:
  - 一个离开窗口的数不是窗口内最大值，说明窗口内有比它大的，说明有比它大的后出现，说明这个数已经被大数干掉了，队列里面没有这个数。 

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums, k: int):
        
        prq = deque()

        result = list()

        for i in range(k):
            while(prq and prq[-1] < nums[i]):
                prq.pop()
            prq.append(nums[i])
        
        result.append(prq[0]) 

        for i in range(len(nums)-k):

            while(prq and prq[-1] < nums[i+k]):
                prq.pop()
            prq.append(nums[i+k])


            if nums[i] == prq[0]: prq.popleft()

            result.append(prq[0])
        
        return result
```



#单调队列