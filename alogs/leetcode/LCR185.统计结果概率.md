[链接](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/)
#组合 #动态规划 #难题 


你选择掷出 `num` 个色子，请返回所有点数总和的概率。

你需要用一个浮点数数组返回答案，其中第 `i` 个元素代表这 `num` 个骰子所能掷出的点数集合中第 `i` 小的那个的概率。

**示例 1：**

**输入：** `num = 3`
**输出：**
```
[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
```

**示例 2：**

**输入：** `num = 5`
**输出:**
```
[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]
```

**提示：**

- `1 <= num <= 11`

# 思路
- ***很多动态规划+数字求和都是这个题的变种***

> **dp数组的定义**
- 首先我们定义动态规划数组: `dp[n][x]` 
  -  $n$ 个骰子，投出和为 $x$  的可能序列个数 
  - 这里的可能情况个数，是按掷出的序列来看的，比如`1,2,3` 和`1,3,2` 是不同的

> **dp数组的长度**
- 对于`dp[n]`， 我们知道其最大和为`6 * n`, 如果为了让数组下标和`x` 能够相对应，我们要保留`x = 0` 状态。
- 由此，对于`dice_number = n` 情况， `len(dp) = 6 * n + 1`

> **dp的初始化**
- 接下来我们来确定`dp[1]` 即初始状态
  - 很显然，对于`dp[1]`, 情况非常有限，就是`dp[0:1+6] = [0,1,1,1,1,1,1]

> **dp的递推公式**
- 关键之处来了，我们要确定`dp[n - 1] -> dp[n]` 递推公式
- 我们知道n个骰子和为x， 仅有的可能情况为：

| n-1个骰子的和 | 第n个骰子的和 |
| ------------- | ------------- |
| x-1           | 1             |
| x-2           | 2             |
| x-3           | 3             |
| x-4           | 4             |
| x-5           | 5             |
| x-6           | 6              |

- 除此以外不会有其他情况使得 n个骰子和为 x
- 也就是说n个骰子和为x 的情况数是 n-1 个骰子和为 x-1 ~ x-6 的情况数之和， 即 :
$$dp[n][x] = \sum_{i = 1}^{6} dp[n-1][x-i]$$
- 若使用滚动数组，则可以从后往前遍历，即可保证数据完整性

> dp递推后的清理工作
- 由于 n 个骰子的和必然不小于 n
- 因此有: $for\ i < n: dp[n][i] = 0$
- 应设置`0~n-1` 处的dp为0

> 骰子的状态空间
- 简单，n个骰子，每个骰子6种可能，有顺序先后之分，因此状态空间为$6^n$

不难写出代码:
```python
class Solution:
    def statisticsProbability(self, num: int):
        total = 6 * num
        dp = [0 for __ in range(total + 1)]
        for i in range(1, 7):
            dp[i] = 1
        
        
        for dice in range(2, num + 1):
            for sums in range(dice * 6, dice - 1, -1):
                dp[sums] = 0
                # dp[sums] = sum(dp[sums-6: sums])
                for i in range(1, 1 + 6):
                    if sums - i < 0: continue
                    dp[sums] += dp[sums - i]
            
            for sums in range(0, dice):
                dp[sums] = 0

		# n 个骰子的排列数状态空间为 6^n
        state_space = pow(6, num)
        for i in range(total + 1):
            dp[i] /= state_space

		# 按题目要求去掉不可能的部分
        return dp[num:]
```