# some basics

**为什么要编码**
- 计算机只储存`bytes` 数据，但面向人类使用时需要给出人类字符与二进制数的对应关系

**编码和解码是什么**
1. `chars -> bytes` 是编码，即encoding
2. `bytes -> chars` 是解码，即decoding

**编码系统需要什么**
1. 被编码的字符集
2. 字符和数的映射关系
3. 在二进制系统中的表示方法

**主流编码的网站支持情况**
![](assets/Pasted%20image%2020240416101743.png)
# ASCII (ISO-8859-1)

**`ASCII` 的字符集**
   `ASCII`charset128个字符，包括英文大小写、数字、标点及一些转义/控制字符
1. 控制字符(0~31及127)
2. 可打印字符(32~126)
    - 32: 空格` `
    - 33~47: 标点符号(1)`!"#$%&'()*+,-./` 
    - 48~57: 数字 `0123456789`
    - 58~64: 标点符号(2) `:;<` `=` `>?@`
    - 65~90: 大写字母 `A~Z`
    - 91~96: 标点符号(3) `[\]^_` 以及" \` "
    - 97~122: 小写字母 `a~z`
    - 123~126: 标点符号(4) `{|}~`

**`ASCII` 的编码方案**
- 直接将字符对应的数字转换为二进制数，由于0~127只需要7个`bit` 就能表示完，所以`ASCII` 只需要一个`bytes`，即8个二进制数或2个16进制数。

# Unicode和UTF
## why and what
Unicode 的目标是**将世界上所有语言的任何字符或符号转换成唯一的数字**。Unicode仍用于字符和二进制数之间的映射，但比ASCII包含更多的字符。[unicode网站](https://home.unicode.org/)

**Unicode的字符集**
- Unicode charset目前包含149878个字符，涵盖161种不同现代或历史文本系统中的字符和符号。

**Unicode的映射方式**
- 字符集中每个定义的字符会被分配一个数字，这个数字为"码点(code node)"。比如汉字的`汉` 在Unicode 中的码点为`0x6C49`，可以用`U+6c49`即`U+`加上16进制下的码点来表示Unicode字符。
 
**Unicode 的编码空间**
- Unicode 把码元划分成了17个空间，称为"编码空间"或平面，每个空间有$2^{16}$(65536)个码点。17个编码空间中只使用了部分平面：
1. `U+0000`~`U+FFFF` 基本多文种平面(BMP)，或称Plane 0、0号平面，包含绝大多数常用字符。
    ![](assets/Pasted%20image%2020240415213320.png)

所有平面如下:

| 平面                 | 范围                    | 中文名           | 英文名                                          |
| ------------------ | --------------------- | ------------- | -------------------------------------------- |
| 0号                 | `U+0000`至`U+FFFF`     | **基本多文种平面**   | Basic Multilingual Plane，**BMP**             |
| 1号                 | `U+10000`至`U+1FFFF`   | **多文种补充平面**   | Supplementary Multilingual Plane, **SMP**    |
| 2号                 | `U+20000`至`U+2FFFF`   | **表意文字补充平面**  | Supplementary Ideographic Plane, **SIP**     |
| 3号                 | `U+30000`至`U+3FFFF`   | **表意文字第三平面**  | Tertiary Ideographic Plane, **TIP**          |
| 4号  <br>至  <br>13号 | `U+40000`至`U+DFFFF`   | （未启用）         |                                              |
| 14号                | `U+E0000`至`U+EFFFF`   | **特别用途补充平面**  | Supplementary Special-purpose Plane, **SSP** |
| 15号                | `U+F0000`至`U+FFFFF`   | **私人使用区（A区)** | Private Use Area-A, **PUA-A**                |
| 16号                | `U+100000`至`U+10FFFF` | **私人使用区（B区)** | Private Use Area-B, **PUA-B**                |

## Unicode的编码方式
 
 Unicode的实现方式不同于编码方式。**一个字符的Unicode码点确定**。但是在实际传输过程中，由于不同[系统平台](https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0 "系统平台")的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为**Unicode转换格式**（Unicode Transformation Format，简称为UTF）。

Unicode的主流编码格式包括了:
1. UTF-8
2. UTF-16
3. GB-18030

### UTF-8

**简介**
- 一种**变长编码**，以单个`bytes`为基本单位，使用1~4个`bytes` 来表示Unicode码点(根据RFC 3629规范)。变长的目的是减少最常用的字符对应Unicode码点的字节使用量。

**Unicode码点范围与所需字节数：**

| 字节数 | 码点范围               | 对应文字                     |
| --- | ------------------ | ------------------------ |
| 1   | `U+0000`~`U+007F`  | **ASCII字符集**             |
| 2   | `U+0080`~`U+07FF`  | 带符号的拉丁文、希腊文、阿拉伯文等        |
| 3   | `U+0800`~`U+FFFF`  | 其他BMP字符，包括大部分常用文字**及汉字** |
| 4   | `U+1000`~`U+1FFFF` | 其他辅助平面                   |

**UTF-8字节规则:**

|码点的位数|码点起值|码点终值|字节序列|Byte 1|Byte 2|Byte 3|Byte 4|Byte 5|Byte 6|
|---|---|---|---|---|---|---|---|---|---|
|7|U+0000|U+007F|1|`0xxxxxxx`|
|11|U+0080|U+07FF|2|`110xxxxx`|`10xxxxxx`|
|16|U+0800|U+FFFF|3|`1110xxxx`|`10xxxxxx`|`10xxxxxx`|
|21|U+10000|U+1FFFFF|4|`11110xxx`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|
|26|U+200000|U+3FFFFFF|5|`111110xx`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|
|31|U+4000000|U+7FFFFFFF|6|`1111110x`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|`10xxxxxx`|

### UTF-16
**简介**
- 一种**变长编码**，以2个`bytes`为基本单位，单个字符可占用单位数为1或2，即使用2~4个`bytes` 来表示Unicode码点。


# GB2312, GBK, GB18030-2000 编码

GB是国标的意思，该系列是我国的国家标准编码方案
## GB2312
**GB2312-80的字符集**
- GB2312字符集包含6763个简体汉字、拉丁字母、希腊字母、日文平假名及片假名、俄语西里尔字母682个字符

**GB2312-80的编码分区**
- GB2312和Unicode类似，把编码空间划分成了94个区，每区含94个汉字/符号。标准中使用了87个区。
1. 01~09区（682个）：特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符；
2. 10~15区：空区，留待扩展
3. 16~55区（3755个）：常用汉字（也称一级汉字），按拼音排序；
4. 56~87区（3008个）：非常用汉字（也称二级汉字），按部首/笔画排序；
5. 88~94区：空区，留待扩展。

**GB2312的编码结构**
- 定长，使用两个字节表示，首个字节为高位字节为分区编号加上一个特定值，第二个字节为对应区段内的个别码位
## GBK
**GBK字符集**
- GBK是对GB2312的扩展，扩展包含了在2312之后才简化的汉字、部分人名用字、港澳台使用的繁体汉字、日语及朝鲜语汉字
- 包含GB2312中全部汉字及非汉字符号
- 包含BIG5中的全部汉字
- 包含与ISO 10646相应的国家标准 GB13000中的其他CJK汉字，以上合计20902个汉字
- 其他汉字、部首、符号共984个

**GBK编码结构**
- GBK使用变长编码方式，使用1~2个字节进行编码![](assets/Pasted%20image%2020240416100118.png)
**GBK兼容性**
- GBK完全向下兼容GB2312的编码，其GBK/1及GBK/2为GB2312对应的编码区域
- GBK向下兼容Big5的字符集
- GBK向上兼容ISO 10646(Unicode)的字符集，但编码需使用映射表
- GBK向上兼容 GB18030
## GB18030
**GB18030的字符集**
- 在GBK基础上，包含了CJK统一汉字扩充A(GB-18030-2000)、汉字扩充B(GB-18030-2005)的汉字，GB-18030-2005收录汉字70244个。

**GB18030编码结构**
- GB18030使用变长编码结构，使用3种不同长度的编码:
1. 1字节: ASCII
2. 2字节: GBK
3. 4字节: 用于填补所有Unicode 码位

# Base16, Base32, Base64

## why and what
- 有些字符在某些环境中无法显示，比如各种转义字符，或者在特定环境中有特殊作用的字符，如`/`， `.` 等字符在URL中的作用。但是有些字符是必定可以显示和使用的，包括字母和数字。
- 如果可以把所有字符编码成必然能打印而且在各种环境中都不会有特殊含义的字符，那就能实现一种通用的通信和存储编码方式了。
- Base 系列的编码方式主要是将二进制数据`0100101..` 以可打印的字符表示出来。
- Base X中的X主要是 “可打印字符” 的数量，因此:
  1. base16使用16个可打印字符来表示所有二进制信息
  2. base32使用32个可打印字符
  3. base64使用64个可打印字符

## base16

**编码过程**
- 每4个bits编码成一个字符，因此可以对每`byte` 编码成两个base16码
- 在编码时，首先把一个`byte`拆分成两个16进制数，然后代入以下的映射关系即可

**映射关系**
实际上就是16进制字符的表示方案罢了

| bin    | base16 | bin    | base16 | bin    | base16 | bin    | base16 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| `0000` | `0`    | `0001` | `1`    | `0010` | `2`    | `0011` | `3`    |
| `0100` | `4`    | `0101` | `5`    | `0110` | `6`    | `0111` | `7`    |
| `1000` | `8`    | `1001` | `9`    | `1010` | `A`    | `1011` | `B`    |
| `1100` | `C`    | `1101` | `D`    | `1110` | `E`    | `1111` | `F`    |

## base32
**编码过程**
- 每5bits编码成一个字符，因此每`5bytes` 编码成8个base32字符
- base32编码过程中，对bin和base32字符串都有补全策略:
  - 当bin位数不足以被5整除时，在右边补`0`直到能被5整除
  - 当转译后的base32字符串不能被8整除时，用`=` 在右边补全至能被8整除

**划分案例**
```text
# 一个5bytes 数据
bin:  00000001 00000011 00000111 00001111 00011111
b32:  00000 00100 00001 10000 01110 00011 11000 11111
b32c:     x     x     x     x     x     x     x     x
```

```text
# 一个6bytes 数据
bin: {00000001 00000011 00000111 00001111 00011111}    {11111111}
b32: {00000 00100 00001 10000 01110 00011 11000 11111} {11111 11100}
b32c:{    x     x     x     x     x     x     x     x} {    x     x = = = = = =}     
```
- 按照规则，把`6bytes` 共`48bits` 的数据按每`5bytes` 划分位两组
- 第一组`40bits` 能被`5bits`整除，所以直接划分成8个base32即可
- 第二组的`8bits`不能被`5bits` 整除，所以首先在bin后补2个0变成`10bits`，然后编码成2个`base32`字符。此时第二组只有两个`b32` 字符，因此用6个`=`补全使其变成8个base32字符

**base32 (RFC4648 §6) 映射表：**
- 这种方案最为常用

| Value | Symbol |     | Value | Symbol |     | Value     | Symbol |
| ----- | ------ | --- | ----- | ------ | --- | --------- | ------ |
| 0     | A      | 8   | I     | 16     | Q   | 24        | Y      |
| 1     | B      | 9   | J     | 17     | R   | 25        | Z      |
| 2     | C      | 10  | K     | 18     | S   | 26        | 2      |
| 3     | D      | 11  | L     | 19     | T   | 27        | 3      |
| 4     | E      | 12  | M     | 20     | U   | 28        | 4      |
| 5     | F      | 13  | N     | 21     | V   | 29        | 5      |
| 6     | G      | 14  | O     | 22     | W   | 30        | 6      |
| 7     | H      | 15  | P     | 23     | X   | 31        | 7      |
|       |        |     |       |        |     | _padding_ | =      |


**base32 Extended Hex Alphabet (拓展字母) 映射表 **
- 这种方案由base16的hex编码进化而来

| Value | Symbol |     | Value | Symbol |     | Value     | Symbol |
| ----- | ------ | --- | ----- | ------ | --- | --------- | ------ |
| 0     | 0      | 8   | 8     | 16     | G   | 24        | O      |
| 1     | 1      | 9   | 9     | 17     | H   | 25        | P      |
| 2     | 2      | 10  | A     | 18     | I   | 26        | Q      |
| 3     | 3      | 11  | B     | 19     | J   | 27        | R      |
| 4     | 4      | 12  | C     | 20     | K   | 28        | S      |
| 5     | 5      | 13  | D     | 21     | L   | 29        | T      |
| 6     | 6      | 14  | E     | 22     | M   | 30        | U      |
| 7     | 7      | 15  | F     | 23     | N   | 31        | V      |
|       |        |     |       |        |     | _padding_ | =      |
## base64
**编码过程**
- 每6个`bits`编码成一个b64字符，因此每`3bytes` bin一组，每组编码成4个b64字符
- base64编码过程中，对bin和base64字符串都有补全策略:
  - 当bin位数不足以被6整除时，在右边补`0`直到能被6整除
  - 当转译后的base64字符串不能被4整除时，用`=` 在右边补全至能被4整除

**划分案例**
```text
# 一个1bytes数据
bin:  01001101+0000 
b64:  010011 010000
b64c:      x      x      =      =

# 一个2bytes数据
bin:  01001101 01100001+00
b64:  010011 010110 000100
b64c:      x      x      x      =

# 一个3bytes数据
bin:  01001101 01100001 01101110
b64:  010011 010110 000101 101110
b64c:      x      x      x      x
```

**RFC4648的标准Base64索引表**


| bin      | b64 | bin      | b64 | bin      | b64 | bin         | b64 |
| -------- | --- | -------- | --- | -------- | --- | ----------- | --- |
| `000000` | `A` | `010000` | `Q` | `100000` | `g` | `110000`    | `w`   |
| `000001` | `B` | `010001` | `R` | `100001` | `h` |  `110001`   | `x`   |
| `000010` | `C` | `010010` | `S` | `100010` | `i` |  `110010`   | `y`   |
| `000011` | `D` | `010011` | `T` | `100011` | `j` |  `110011`   | `z`   |
| `000100` | `E` | `010100` | `U` | `100100` | `k` |  `110100`   | `0`   |
| `000101` | `F` | `010101` | `V` | `100101` | `l` |  `110101`   | `1`   |
| `000110` | `G` | `010110` | `W` | `100110` | `m` |  `110110`   | `2`   |
| `000111` | `H` | `010111` | `X` | `100111` | `n` |  `110111`   | `3`   |
| `001000` | `I` | `011000` | `Y` | `101000` | `o` |  `111000`   | `4`   |
| `001001` | `J` | `011001` | `Z` | `101001` | `p` |  `111001`   | `5`   |
| `001010` | `K` | `011010` | `a` | `101010` | `q` |  `111010`   | `6`   |
| `001011` | `L` | `011011` | `b` | `101011` | `r` |  `111011`   | `7`   |
| `001100` | `M` | `011100` | `c` | `101100` | `s` |  `111100`   | `8`   |
| `001101` | `N` | `011101` | `d` | `101101` | `t` |  `111101`   | `9`   |
| `001110` | `O` | `011110` | `e` | `101110` | `u` |  `111110`   | `+`   |
| `001111` | `P` | `011111` | `f` | `101111` | `v` |  `111111`   | `/`   |
|          |     |          |     |          |     | padding     | `=`   |
不同标准

# 编码错误对照

| 名称  | 示例                                | 特点                          | 产生原因                                |
| --- | --------------------------------- | --------------------------- | ----------------------------------- |
| 古文码 | 鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?                 | 大都为不认识的古文，并加杂日韩文            | 以GBK方式读取UTF-8编码的中文                  |
| 口字码 | ����Ҫ�¨²�ѧϰ������                 | 大部分字符为小方块                   | 以UTF-8的方式读取GBK编码的中文                 |
| 符号码 | ç±æè¦å¥½å¥½å­¦ä¹ å¤©å¤©åä¸ | 大部分字符为各种符号                  | 以ISO8859-1方式读取UTF-8编码的中文            |
| 拼音码 | ÓÉÔÂÒªºÃºÃÑ§Ï°ÌìÌìÏòÉÏ            | 大部分字符为头顶带有各种类似声调符号的字母       | 以ISO8859-1方式读取GBK编码的中文              |
| 问句码 | 由月要好好学习天天向??                      | 字符串长度为偶数时正确，长度为奇数时最后的字符变为问号 | 以GBK方式读取UTF-8编码的中文，然后又用UTF-8的格式再次读取 |
| 锟拷码 | 锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷            | 全中文字符，且大部分字符为“锟斤拷”这几个字符     | 以UTF-8方式读取GBK编码的中文，然后又用GBK的格式再次读取   |
