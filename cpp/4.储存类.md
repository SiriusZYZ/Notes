# static关键字

## 静态存储区
- static被引入以告知编译器，将**变量存储在程序的静态存储区而非栈上空间**
>栈空间特点：
1. 函数嵌套运行也是根据栈来的，函数运行时入栈，退出时出栈
2. 函数运行时，函数指针和函数的变量随之加入栈空间
3. 函数退出时，函数指针及函数的变量随之出栈
4. 如果变量定义在栈空间上，变量的生存期就是函数的运行时间，函数一旦退出，变量便会释放
> 静态储存区的特点
1. 在 **程序** 启动时分配对象或变量，在程序结束时 **释放**
2. 变量的生存期是整个进程运行时间，而不是函数的运行时间

## 内部链接
- 内部链接指变量或函数的可见范围为当前编译单元
- 外部链接指变量或函数对本编译单元外部可见，以一个标志来提供接口


## static变量的初始化
- `static` 的初始化只在声明的时候进行，只进行一次。
-  如果声明时不进行定义，编译器会为其指定一个0作为初始值
- 比如一个函数中定义的`static` 变量，在函数运行前该变量已经初始化，但对函数以外的地方不可见。函数调用时不会执行声明的那个初始化语句，而是跳过其执行

## 作用

| 作用对象 | 作用效果                                  |
| -------- | ----------------------------------------- |
| 局部变量 | 改变生命周期，将局部变量存放在静态储存区  |
| 全局变量 | 改变可见性，使之仅在本文件/编译模块中可见 |
| 函数     | 改变可见性，使之仅在本文件/编译模块中可见 |
| 类属性   | 该数据成员为所有实例对象共有，且可以不实例化就可以访问                  |
| 类方法   | 该方法为所有实例对象共有，且可以不实例化就可以访问                                        |


- `static` 修饰的类方法，由于属于所有实例，因此不包含`this` 指向本身的指针，因此智能方位类中的`static`对象

- `static` 主要作用包括了
  1. 修饰变量为静态变量改变其生存期
  2. 修饰变量为内部链接变量以改变其可见范围
  3. 修饰函数具有内部链接，使得其对外不可见
  4. 修饰类属性时，使得所有实例对象都共享该属性
  5. 修饰类方法时，使得所有实例对象共享该方法，该方法可以不经实例化就能直接调用，同时也不接受this指针作为输入
- `static` 关键字要求提供初始化

> 修饰函数中的变量为静态变量
```cpp
#include <iostream>
using namespace std;
void showstat( int curr ) {
   static int nStatic;    // 静态变量, 函数退出不会释放
                          // between each function call
   nStatic += curr;
   cout << "nStatic is " << nStatic << endl;
}
int main() {
   for ( int i = 0; i < 5; i++ )
      showstat( i );
}

Output:
nStatic is 0 
nStatic is 1 
nStatic is 3 
nStatic is 6 
nStatic is 10
```

> 修饰类中的属性为静态变量
```cpp
#include <iostream>
using namespace std;
class CMyClass {
public:
   static int m_i;
};

int CMyClass::m_i = 0;    // 从外部修改
CMyClass myObject1;
CMyClass myObject2;

int main() {
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   myObject1.m_i = 1;  
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   myObject2.m_i = 2;
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   CMyClass::m_i = 3;
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;
}

output:
0
0
1
1
2
2gan
3
3
```


# const

## 作用

| 作用对象 | 作用效果                                                          |
| -------- | ----------------------------------------------------------------- |
| 指针常量 | `const Type * p` 表示p指向了一个常量                              |
| 常量指针 | `Type* const p` 表示p是指针，同时是一个常量，即不能变更指向的对象 |
| 形参     | `const Type & p` 表示p是一个"常量引用"，函数内无法改变p的引用对象 | 



# extern关键字
- 与内部链接相反，`extern` 关键字可以用来声明修饰对象外部可见


# volatile关键字
- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
- 简而言之，就是修饰的对象，每次访问都应该从内存访问。
- 由于进程之间可能会共享某个变量，所以该变量应该保存在内存中而不是CPU寄存器中，用volatile修饰以后可以保证每次访问该变量都是从内存访问，而不会造成一个进程访问了寄存器的值，一个访问了内存的值造成不一致情况

# auto

- 自C++17后auto 不在作为储存类说明符
- **auto** 关键字用于两种情况：
  1. 声明变量时根据初始化表达式自动推断该变量的类型
  2. 声明函数时函数返回值的占位符。

1. 使用auto来代替初始化表达式来判断变量类型
   **使用auto 声明的变量序列要求是同一类型的数据**
```cpp
auto f=3.14; //double 
auto s("hello"); //const char* 
auto z = new auto(9); // int* 
auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型
```
2. 使用auto 来代替函数返回值的声明
   使用auto声明的函数不能存在返回不同类型数据的情况
```cpp
auto func(int x){
	return double(x)
}

auto func(int x){
	if (x > 0)
	{
		return double(x)
	}
	else
	{
		return x
	}
}//错误，要求只能返回同种类型
```
# register
- 自C++17开始，register关键字被弃用
- **register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。


