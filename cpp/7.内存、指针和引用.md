# 7.0内存

| 位置            | 管理   | 内容                                      |
| --------------- | ------ | ----------------------------------------- |
| 栈              | 编译器 | 局部变量及局部常量、函数参数、函数指针    |
| 堆              | 程序员 | 使用new, delete, malloc, free分配的堆空间 |
| 全局/静态储存区 | 编译器 | 存储全局变量与静态变量                    |
| 常量存储区      | 编译器 | 存储字面值常量                            |
| 代码区          | 编译器 | 储存指令                                  |

# 7.1指针

- 指针使用`*` 作为标识符， 我们认为其运算上的优先级比`[]`高，因此：
```cpp
int *p[10];  // 指针数组，可以理解为(int *)p[10]，即长10，内容为int*的数组
int (*p)[10]; // 数组指针，(*p) 强调了这是一个指针，指向一个int[10]数组

int* p(int); // 返回一个整型指针的数组
int (*p)(int); // 一个接受int， 返回int 的函数的指针
```

## 7.1.1|指针与引用的区别

|          | 指针             | 引用                           |
| -------- | ---------------- | ------------------------------ |
| 本质区别 | 指向对象的地址   | - 原变量的别名                 |
| 结构     | 允许多级指针     | 引用只有一级                   |
| 空值     | 可为空           | 不能为空且必须定义时要初始化   |
| 可变性   | 可变更指向的对象 | 初始化后不可变更指向的对象     |
| `sizeof` | 返回指针的大小   | 返回引用对象的大小                 |
| 传参     | 形参与实参分离   | 注意是别名，修改形参会影响实参 |

## 7.1.2|函数传参什么时候用指针什么时候用引用

- 返回函数内的局部变量时使用指针。具体做法是把局部变量的赋给传入指针指向的对象


## 7.1.2智能指针

>==**包**==
>智能指针是在`<memory>` 头文件中的`std` 命名空间里定义的
```cpp
#include <memory>
using namespace std;
```

>==**作⽤：**==
>管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况滴发⽣。

>**==实现方式：==**
>智能指针实际上是一个类。我们知道对象是有作用域的，当离开作用域，会调用对象的析构函数。因此在离开智能指针作用域后就会调用其析构函数，使之释放内存。

```cpp
T* get();   // 获取智能指针的真正指针
T& operator*();  
T* operator->();
T& operator=(const T& val);
T* release();  // 释放指针所有权，置空内部指针
void reset (T* ptr = nullptr); // 释放所有权并释放指针对应内存
```

实现智能指针一共有4种不同的方案：
1. `auto_ptr`，采用所有权方式。其特点是`=` 的重载中，左值会得到右值的所有权，右值释放指针所有权。此后再访问右值时会报错。
```cpp
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
p1.dosomething(); // 报错
```
这种智能指针容易造成内存崩溃。

2. `unique_ptr`，采用严格的所有权方式。不允许使用`=` 来进行移权操作。编译器会认为`p4=p3`非法，从而引发错误。
```cpp
unique_ptr<string> p3 (new string (auto));//#4
unique_ptr<string> p4；//#5
p4 = p3;//此时会报错
```

3. `shared_ptr` 允许多个智能指针指向同一个对象，并使用引用计数来控制释放。
   - 可以传入`auto_ptr`, `unqiue_ptr`, `weak_ptr` 来构造，或使用new构造
   - 使用引用计数来控制释放，可以用`use_count()` 方法来得到智能指针指向的资源的所有者数量
   - `release()` 或指向另一个位置会使得原对象引用计数-1， 当引用计数=0时释放内存资源
```cpp
auto p1 = std::make_shared<int>(10); // 可以使用make_shared 来创建share_ptr
std::shared_ptr<int> p2(p1);
std::cout << p1.use_count();         // >>> 2

auto p3 = std::make_shared<int>(20);
p2 = p3;
std::cout << p1.use_count() << p2.use_count(); // >>> 12

```
- 与其他引用计数法相似，会造成循环引用问题
```cpp
class A{
public: std::shared_ptr<B> instance;
}

class B{
public: std::shared_ptr<A> instance;
}

std::shared_ptr<A> a(new A);
std::shared_ptr<B> b(new B);
a->instance = b;
b->instance = a;
std::cout << a.use_count() << b.use_count(); // >>> 22
```
  - a 是一个指向 一个A对象的智能指针， b 是指向一个B对象的智能指针。
  - 当a, b退出作用域时，a, b指向的A, B对象引用计数都会-1，使得两者引用计数为1.
  - 然而，由于A的引用计数为1，因此不会调用其析构函数，即不会释放其instance，使得B引用计数能够-1。B也如此。
  - 这样的结果就是由于A, B引用计数均不为0， 因此都不会调用其析构函数，就均不会使得对方引用计数-1，造成一种死锁的局面
  
4. `weak_ptr` 不控制对象生命周期。
   - `weak_ptr` 指向某个`share_ptr` 管理的对象。但是该对象的内存管理由`share_ptr`负责
   - `weak_ptr` 是一个不会造成引用计数+1或-1的智能指针，因此被称为“弱引用”。可以很好地解决循环引用问题
```cpp
auto p1 = std::make_shared<int>(10); 
std::weak_ptr<int> p2(p1);
std::cout << p1.use_count();         // >>> 1
```

# 7.2new,delete,malloc,free

- `new`, `delete` 是 C++引入的关键字
- `malloc`, `free` 是 C/C++ 的标准库函数

> new 的实现过程
> 1. 调用 operator new 标准库函数，自动计算所需内存大小，并使用malloc分配内存。
> 2. 运行构造函数并初始化构造对象
> 3. 返回新分配并构造后的对象指针

> delete 实现过程
> 1. 对指向的对象调用其析构函数
> 2. 调用 operator delete 标准库函数释放对象内存

new 与 malloc的区别是:

|        | new          | malloc           |
| ------ | ------------ | ---------------- |
| 说明   | C++ 关键字   | C/C++ 标准库函数 |
| 类型   | 类型安全     | 类型不安全       |
| 返回   | 特定类型指针 | void指针         |
| 参数   | -            | 字节数           |
| 类操作 | 调用构造函数 | 无操作           |

delete 与 free 的区别是：

|        | delete       | free             |
| ------ | ------------ | ---------------- |
| 说明   | C++ 关键字   | C/C++ 标准库函数 |
| 类操作 | 调用析构函数 | 无操作           |
