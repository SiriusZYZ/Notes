# 5.1 Shell变量基础

## 5.1.1 变量的定义和访问

**命名规则**
1. 只能包含字母、数字、下划线`_`，不能包含其他字符，不能以数字开头
2. 大小写敏感
3. 避免使用关键字，如`if`, `then`, `else`, `fi`, `for`, `while` 等

**命名规范**
1. 使用全大写表示常量或不会修改的量
2. 应顾名思义

**bash弱类型特性**
- 声明和定义同时进行，`varname=value` 中间不能有任何空格。
- bash默认变量都是字符串

**定义变量**
- 使用等号连接变量名和变量值
- 两者之间不能有空格
```shell
var_name=var_value
```
- 也可以将指令的结果作为字符串赋给变量:
```shell
var_name=`command`
var_name=$(command)
```
- 例如:
```shell
~$ a=`pwd`
~$ echo $a
/home/sirius
~$ a=$(pwd)
~$ echo $a
/home/sirius
```

**访问变量**
- 使用`${Varname}`访问变量，其中花括号可以加或不加
- 花括号的主要作用是在后接其他文字时界定变量名，见以下案例
- 因此，花括号括起是一种较好的习惯
```shell
sirius@B546-ZYZ:~$ var_sa="xixi"
sirius@B546-ZYZ:~$ echo ${var_sa}
xixi
sirius@B546-ZYZ:~$ echo $var_sa
xixi
# 花括号可以界定变量名，使之在后面能接其他东西
sirius@B546-ZYZ:~$ echo ${var_sa}haha
xixihaha
```

## 5.1.2 变量的作用域

**核心: 不同进程shell中的变量不共享，环境变量只往下传**

**Shell 变量作用域的类型**
- 局部变量: 仅能在函数内部使用
- 全局变量: 能在当前Shell及当前shell执行的脚本中使用
- 环境变量: 子进程的shell中能使用父进程的环境变量，子Shell的子Shell也可以用

| 变量类型 | 函数内可用 | 脚本中可用 | 本shell中可用 | 子Shell可用 |
| ---- | ----- | ----- | --------- | -------- |
| 局部变量 | Y     | N     | N         | N        |
| 全局变量 | Y     | Y     | Y         | N        |
| 环境变量 | Y     | Y     | Y         | Y        |


**局部变量**
- 定义时要满足以下要求:
  1. 在脚本的函数内部定义
  2. 使用`local`进行修饰，如果不使用`local` ，则在函数外部仍可能可见
- 局部变量仅能在所定义的函数内访问
```shell
sirius@B546-ZYZ:~$ cat test.sh
#! /bin/bash
function func(){
a=99
local b=88
}

func
echo $a
echo $b
sirius@B546-ZYZ:~$ ./test.sh
99    # 可以访问到函数内部的变量
      # 无法访问函数内部的local 变量
> echo $a
>     # Shell不会访问到脚本内部定义的变量
```

**全局变量**
- 在当前整个Shell进程中都有作用
- 定义方式可以为
  - 直接通过Shell定义的变量
  - 在脚本中定义的全局变量
```shell
sirius@B546-ZYZ:~$ echo $b

sirius@B546-ZYZ:~$ cat test.sh
#! /bin/bash
echo $a
b=20                          # 在脚本中定义了全局变量 b
sirius@B546-ZYZ:~$ a=100      # 在shell 中定义了全局变量 a
sirius@B546-ZYZ:~$ . test.sh  # 脚本中能访问Shell定义的全局变量
100
sirius@B546-ZYZ:~$ echo $b    # Shell中能访问脚本中定义的变量
20
```

**环境变量**
- 定义用`export` 导出变量为环境变量
  - `export varname=value` 即在"导出"同时赋值
  - `export existed_var` 即导出已定义的变量
- 环境变量可被子进程和子子进程访问
```shell
(parent) $ a=22     #定义全局变量 
(parent) $ echo $a  #在当前Shell中输出a，成功 
22 
(parent) $ bash     #进入Shell子进程 
(child)  $ echo $a  #子进程无法访问父进程全局变量 

(child)  $ exit     #退出子进程
(parent) $ export a #将父进程的全局变量a导出为环境变量 
(parent) $ bash     #进入子进程 
(child)  $ echo $a  #在子进程中可以访问父进程环境变量 
22 
```

## 5.1.3 特殊变量

**上一命令执行情况`$?`**
 - `$?` 变量，上一条命令执行的状态码
   - `0` 为成功执行
   - `1~255` 为不成功
```shell
 sirius@B546-ZYZ:~$ cd abcdefg
-bash: cd: abcdefg: No such file or directory
sirius@B546-ZYZ:~$ echo $?
1
```

**进程的PID`$$`**
```shell
$ echo $$
154
$ bash     # 进入子Shell
$ echo $$
292
```

## 5.1.4 变量的删除
```shell
unset {var_name}
```
- 使用`unset` 可以将对应的变量删除，使之成为空字符串
- `unset` 一个不存在的变量时不会报错

```shell
$: cat test.sh
#!/bin/sh  
  
a="haha"  
unset a  
echo $a
$: . test.sh
$:
```

## 5.1.5 只读变量
```shell
readonly {varname}
```
- 使用`readonly`修饰已经定义的变量名，使其后续不能被改变

# 5.2 字符串

**Shell中的字符串**
- Shell中定义的变量默认为字符串
- 字符串可以用单引号包围，也可以用双引号包围，也可以不包围
  1. `'str'` 单引号字符串禁止字符串中的任何转义
  2. `"str"` 双引号字符允许字符串内的转义
  3. ` str ` 不用引号包围的字符串允许内部转义
> Python有着类似的字符串定义规则，即可以用单引号或者双引号。一些人的编程习惯中，双引号被用于人类阅读字符串，单引号被用于数据。通常数据不需要各种转义字符，但双引号可能需要。

**字符串内转义**：可以在双引号包围的或无引号包围的字符串中
1. 访问其他变量来实现拼接
2. 字符串的其他操作

**字符串的长度**
- 使用`${#varname}` 可以求出字符串的长度
```shell
$ a="1234567890"
$ echo ${#a}
10
```

## 5.2.1 字符串解析、拼接

```shell
~$ a="haha"
~$ b="i am $a"
~$ c='i am $a'
~$ echo b
b
~$ echo $b
i am haha
~$ echo $c
i am $
```
- 如果用双引号包围字符串，则其中的`${varname}`会解析为对应的变量，如上面的`b`
- 使用单引号包围字符串，则其中不会发生任何解析


```shell
sirius@B546-ZYZ:~$ a="a"
sirius@B546-ZYZ:~$ b="b"
sirius@B546-ZYZ:~$ c=$a$b
sirius@B546-ZYZ:~$ d=$a $b
b: command not found
sirius@B546-ZYZ:~$ e="$a $b"
sirius@B546-ZYZ:~$ echo $c "," $e
ab , a b
```
- 字符串拼接，可以直接使用用两个解析符号拼接，如`$a$b` 也可以用双引号解析拼接

## 5.2.2 字符串的切片
**切片的两种主要方式**:
- 以索引切片
- 以字符匹配切片

### 5.2.2.1 索引切片

字符串的索引从0开始

**正切片**
- `${var_name: start :length}` 即在`var_name`中从索引`start` 开始截取长度为`length` 的子串，如果省略`length` 则截取到字符串末尾
```shell
$ a="0123456789"
$ echo ${a:3:5}
34567
$ echo ${a:3}
3456789
# 以下是各种奇奇怪怪情况
$ echo ${a:3:15}   # 溢出的情况下不报错, 保留到字符串末尾
3456789
$ echo ${a:15:3}   # 溢出不报错，如果超过范围则什么都不返回

$ echo ${a:3:0}    # length可以为0

# 以下是start或length为负的情况
$ echo ${a:3:-4}   # 当start为正而length为负时，这时相当于python的a[3:-4], length被作为结束下标使用了
345
$ echo ${a:-3:x}    # 当start为负时, 无论length设置为正或负或0或不设置, 都把整个字符串输出
0123456789
```

**负切片**
- `${var_name:0-start:length}` 即在`var_name`中从尾部数`start`个并开始截取长度为`length` 的子串，省略`length`也是截取到字符串末尾
```shell
$ a="0123456789"
$ echo ${a:0-3}
789
$ echo ${a:0-3:2}
78
$ echo ${a:0-6:-2}  # 如果length是负数时, 也是相当于python的end
4567
$ echo ${a:0-10:5}  
01234
$ echo ${a:0-11:5}  # 和上一行对比, 一旦start溢出就不显示, 就算加上0-11+5落在正确区间内

```

### 5.2.2.2 字符匹配切片

**匹配`regx`并保留其右侧子串**
- `regx` 可以是由`*` 之类的东西做成的匹配表达式, 比如`*a`，`*a*b`等，`regx` 末尾的所有星号会被忽略
- 使用`${str#regx}`, 保留从左侧数起第一个匹配到位置的右边子串，不保留匹配到的子串
- 使用`${str##regx}`, 保留从左侧数起最后一个匹配到位置的右边子串，不保留匹配到的子串
```shell
$ a="123412341234"
$ echo ${a#12} #匹配首个"12"
3412341234
$ echo ${a#21*} # 匹配不成功则返回所有
123412341234
$ echo ${a#*34} #
12341234
$ echo ${a#12*}
3412341234

```