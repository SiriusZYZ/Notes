# 5.1 Shell变量基础

## 5.1.1 变量的定义和访问

**命名规则**
1. 只能包含字母、数字、下划线`_`，不能包含其他字符，不能以数字开头
2. 大小写敏感
3. 避免使用关键字，如`if`, `then`, `else`, `fi`, `for`, `while` 等

**命名规范**
1. 使用全大写表示常量或不会修改的量
2. 应顾名思义

**bash弱类型特性**
- 声明和定义同时进行，`varname=value` 中间不能有任何空格。
- bash默认变量都是字符串

**定义变量**
- 使用等号连接变量名和变量值
- 两者之间不能有空格
```shell
var_name=var_value
```
- 也可以将指令的结果作为字符串赋给变量:
```shell
var_name=`command`
var_name=$(command)
```
- 例如:
```shell
~$ a=`pwd`
~$ echo $a
/home/sirius
~$ a=$(pwd)
~$ echo $a
/home/sirius
```

**访问变量**
- 使用`${Varname}`访问变量，其中花括号可以加或不加
- 花括号的主要作用是在后接其他文字时界定变量名，见以下案例
- 因此，花括号括起是一种较好的习惯
```shell
sirius@B546-ZYZ:~$ var_sa="xixi"
sirius@B546-ZYZ:~$ echo ${var_sa}
xixi
sirius@B546-ZYZ:~$ echo $var_sa
xixi
# 花括号可以界定变量名，使之在后面能接其他东西
sirius@B546-ZYZ:~$ echo ${var_sa}haha
xixihaha
```

## 5.1.2 declare指定变量属性

```shell
declare [+/-] [opt] varname
```

| 选项  | 含义                | 备注                   |
| --- | ----------------- | -------------------- |
| -   | 给变量**设定**类型属性     |                      |
| +   | **取消**变量的类型属性     |                      |
| -a  | 将变量声明为数组类型        |                      |
| -i  | 将变量声明为整数型         |                      |
| -x  | 将变量声明为环境变量        | 等价于加入关键字`export`     |
| -r  | 将变量声明为只读变量        | 等价于加入关键字`readonly`   |
| -p  | **显示**指定变量的被声明的类型 | `declare -p varname` |
- 必须注意的是`+` 是取消定义类型, `-` 是设定类型
```shell
$ a=1                # 默认是字符串
$ b=2
$ c=$a+$b            # c也默认是字符串，所以变成解析表达了. 就算a, b已经定义为整形, 仍会当成字符串
$ echo $c
1+2
$ declare -i c=$a+$b # 声明成整型以后能正确计算, 这里相当于eval()函数了
$ echo $c
3
$ declare +i c       # 取消变量的类型属性
$ c=$a+$b
$ echo $c
1+2

$ declare -i aa=5
$ declare -p aa      # 会返回定义的类型 -i
declare -i aa="5"
$ bb=5
$ declare -p bb
declare -- bb="5"
$ declare -r bb
$ declare -p bb      # 也会返回类型定义时的read only
declare -r bb="5"
```



## 5.1.3 变量的作用域

**核心: 不同进程shell中的变量不共享，环境变量只往下传**

**Shell 变量作用域的类型**
- 局部变量: 仅能在函数内部使用
- 全局变量: 能在当前Shell及当前shell执行的脚本中使用
- 环境变量: 子进程的shell中能使用父进程的环境变量，子Shell的子Shell也可以用

| 变量类型 | 函数内可用 | 脚本中可用 | 本shell中可用 | 子Shell可用 |
| ---- | ----- | ----- | --------- | -------- |
| 局部变量 | Y     | N     | N         | N        |
| 全局变量 | Y     | Y     | Y         | N        |
| 环境变量 | Y     | Y     | Y         | Y        |


**局部变量**
- 定义时要满足以下要求:
  1. 在脚本的函数内部定义
  2. 使用`local`进行修饰，如果不使用`local` ，则在函数外部仍可能可见
- 局部变量仅能在所定义的函数内访问
```shell
sirius@B546-ZYZ:~$ cat test.sh
#! /bin/bash
function func(){
a=99
local b=88
}

func
echo $a
echo $b
sirius@B546-ZYZ:~$ ./test.sh
99    # 可以访问到函数内部的变量
      # 无法访问函数内部的local 变量
> echo $a
>     # Shell不会访问到脚本内部定义的变量
```

**全局变量**
- 在当前整个Shell进程中都有作用
- 定义方式可以为
  - 直接通过Shell定义的变量
  - 在脚本中定义的全局变量
```shell
sirius@B546-ZYZ:~$ echo $b

sirius@B546-ZYZ:~$ cat test.sh
#! /bin/bash
echo $a
b=20                          # 在脚本中定义了全局变量 b
sirius@B546-ZYZ:~$ a=100      # 在shell 中定义了全局变量 a
sirius@B546-ZYZ:~$ . test.sh  # 脚本中能访问Shell定义的全局变量
100
sirius@B546-ZYZ:~$ echo $b    # Shell中能访问脚本中定义的变量
20
```

**环境变量**
- 定义用`export` 导出变量为环境变量
  - `export varname=value` 即在"导出"同时赋值
  - `export existed_var` 即导出已定义的变量
- 环境变量可被子进程和子子进程访问
```shell
(parent) $ a=22     #定义全局变量 
(parent) $ echo $a  #在当前Shell中输出a，成功 
22 
(parent) $ bash     #进入Shell子进程 
(child)  $ echo $a  #子进程无法访问父进程全局变量 

(child)  $ exit     #退出子进程
(parent) $ export a #将父进程的全局变量a导出为环境变量 
(parent) $ bash     #进入子进程 
(child)  $ echo $a  #在子进程中可以访问父进程环境变量 
22 
```

## 5.1.4 特殊变量

**上一命令执行情况`$?`**
 - `$?` 变量，上一条命令执行的状态码
   - `0` 为成功执行
   - `1~255` 为不成功
```shell
 sirius@B546-ZYZ:~$ cd abcdefg
-bash: cd: abcdefg: No such file or directory
sirius@B546-ZYZ:~$ echo $?
1
```

**进程的PID`$$`**
```shell
$ echo $$
154
$ bash     # 进入子Shell
$ echo $$
292
```

## 5.1.5 变量的删除
```shell
unset {var_name}
```
- 使用`unset` 可以将对应的变量删除，使之成为空字符串
- `unset` 一个不存在的变量时不会报错

```shell
$: cat test.sh
#!/bin/sh  
  
a="haha"  
unset a  
echo $a
$: . test.sh
$:
```

## 5.1.6 只读变量
```shell
readonly {varname}
```
- 使用`readonly`修饰已经定义的变量名，使其后续不能被改变

# 5.2 字符串

**Shell中的字符串**
- Shell中定义的变量默认为字符串
- 字符串可以用单引号包围，也可以用双引号包围，也可以不包围
  1. `'str'` 单引号字符串禁止字符串中的任何转义
  2. `"str"` 双引号字符允许字符串内的转义
  3. ` str ` 不用引号包围的字符串允许内部转义
> Python有着类似的字符串定义规则，即可以用单引号或者双引号。一些人的编程习惯中，双引号被用于人类阅读字符串，单引号被用于数据。通常数据不需要各种转义字符，但双引号可能需要。

**字符串内转义**：可以在双引号包围的或无引号包围的字符串中
1. 访问其他变量来实现拼接
2. 字符串的其他操作

**字符串的长度**
- 使用`${#varname}` 可以求出字符串的长度
```shell
$ a="1234567890"
$ echo ${#a}
10
```

## 5.2.1 字符串解析、拼接

```shell
~$ a="haha"
~$ b="i am $a"
~$ c='i am $a'
~$ echo b
b
~$ echo $b
i am haha
~$ echo $c
i am $
```
- 如果用双引号包围字符串，则其中的`${varname}`会解析为对应的变量，如上面的`b`
- 使用单引号包围字符串，则其中不会发生任何解析


```shell
sirius@B546-ZYZ:~$ a="a"
sirius@B546-ZYZ:~$ b="b"
sirius@B546-ZYZ:~$ c=$a$b
sirius@B546-ZYZ:~$ d=$a $b
b: command not found
sirius@B546-ZYZ:~$ e="$a $b"
sirius@B546-ZYZ:~$ echo $c "," $e
ab , a b
```
- 字符串拼接，可以直接使用用两个解析符号拼接，如`$a$b` 也可以用双引号解析拼接

## 5.2.2 字符串的切片
**切片的两种主要方式**:
- 以索引切片
- 以字符匹配切片

### 5.2.2.1 索引切片

字符串的索引从0开始

**正切片**
- `${var_name: start :length}` 即在`var_name`中从索引`start` 开始截取长度为`length` 的子串，如果省略`length` 则截取到字符串末尾
```shell
$ a="0123456789"
$ echo ${a:3:5}
34567
$ echo ${a:3}
3456789
# 以下是各种奇奇怪怪情况
$ echo ${a:3:15}   # 溢出的情况下不报错, 保留到字符串末尾
3456789
$ echo ${a:15:3}   # 溢出不报错，如果超过范围则什么都不返回

$ echo ${a:3:0}    # length可以为0

# 以下是start或length为负的情况
$ echo ${a:3:-4}   # 当start为正而length为负时，这时相当于python的a[3:-4], length被作为结束下标使用了
345
$ echo ${a:-3:x}    # 当start为负时, 无论length设置为正或负或0或不设置, 都把整个字符串输出
0123456789
```

**负切片**
- `${var_name:0-start:length}` 即在`var_name`中从尾部数`start`个并开始截取长度为`length` 的子串，省略`length`也是截取到字符串末尾
```shell
$ a="0123456789"
$ echo ${a:0-3}
789
$ echo ${a:0-3:2}
78
$ echo ${a:0-6:-2}  # 如果length是负数时, 也是相当于python的end
4567
$ echo ${a:0-10:5}  
01234
$ echo ${a:0-11:5}  # 和上一行对比, 一旦start溢出就不显示, 就算加上0-11+5落在正确区间内

```

### 5.2.2.2 字符匹配切片

**匹配`regx`并保留其右侧子串**: `#`
- `regx` 可以是由`*` 之类的东西做成的匹配表达式, 比如`*a`，`*a*b`等，`regx` 末尾的所有星号会被忽略
- 使用`${str#regx}`, 保留从左侧数起第一个匹配到位置的右边子串，不保留匹配到的子串
- 使用`${str##regx}`, 保留从左侧数起最后一个匹配到位置的右边子串，不保留匹配到的子串
```shell
$ a="123412341234"
$ echo ${a#12} #匹配首个"12"
3412341234
$ echo ${a#21*} # 匹配不成功则返回所有
123412341234
$ echo ${a#*34} #
12341234
$ echo ${a#12*}
3412341234

$ echo ${a##*12} # 匹配最后一个*12，截取后面的内容
34
```


**匹配`regx` 并保留其左边的字符串**: `%`
- 使用`${str%regx}`, 保留从**右侧数起第一个**匹配到位置的左边子串
- 使用`${str%%regx}`, 保留从**右侧数起最后一个**匹配到位置的左边子串
```shell
$ a="123412341234"
$ echo ${a%*23*}
123412341
$ echo ${a%%23*}
1
```

# 5.3 列表

**Shell中的列表**
- shell中的列表是一种稀疏列表，即允许某些下标的值没有指定
- 列表中的空值仍会被索引，但在却不计入列表长度中 (好奇怪)
- 列表是弱类型的，允许存在类型不一致的列表
- 从以上角度看，Shell中列表更类似于以递增索引为键值的哈希表

**列表的定义**
- 用`()` 来括起列表的元素，元素之间用` `(space)来分隔
- 可以在定义时使用解析表达的方式
```shell
nums=(1 2 3 "4")   # 列表元素可以不是一个类型
a=15
nums=(
$a    # 支持在定义时使用解析表达
2     # 换行也没问题(在脚本中)
3 
4)    
```

**列表的长度**
- 使用`${#list[*]}` 或`${#list[@]}` 来获取列表长度，这和字符串求长度类似
- 如果不加`[*]` 则会变成获取列表首个元素的长度
- 列表中的空值仍会被索引，但在却不计入列表长度中 (好奇怪)
```shell
$ nums=(aa bb cc)
$ nums[1000]=dd
$ echo ${nums[1000]} # 中间是稀疏的，索引访问时都会omit，1000这个位置对应键所映射的值
dd
$ echo ${#nums}    # 不加[*]就会变成求首个元素长度
2
$ echo ${#nums[*]} # 求已经定义的元素个数, 但是这真绝了
4
```
- 由此观之，shell中的列表更像字典，没定义的键值不会指向任何东西，求列表长度的时候是统计表中有多少个键值对

**访问数组的所有元素**
- 解析表达式`${list[@]}` 
- 解析表达式 `${list[*]}`
```shell
$ nums=(1 2 3 "4")   
$ echo ${nums[@]}
1 2 3 4
$ echo ${nums[*]}
1 2 3 4
```

**以索引的方式访问元素**
- `list[index]=new_value` 以索引方式**修改**数组元素的值
- `${list[index]}` 以索引方式**读取**数组元素的值
```shell
$ nums=(0 1 2 3)
$ echo ${nums[2]}   # 读取元素
2
$ ${nums[2]}=8      # 不能用这种方式修改元素, 这是因为$号本质是个解析器, 解析后就和原来指向的东西不一样了
2=8: command not found
$ nums[2]=8         # 可以用这种方式修改数组元素
$ echo ${nums[@]}
0 1 8 3
$ nums[4]="new_element" # 可以在列表尾部以赋值方式添加新元素
$ echo ${nums[@]}
0 1 8 3 new_element
```

**删除元素**
- 使用`unset` 关键字删除某个元素
- 列表元素删除不会改变其他索引位置的值，从这点看这真的不像一个列表，更像哈希表
```shell
$ nums=(0 1 2 3 4)
$ echo "arr: ${nums[@]}, len: ${#nums[@]}"
arr: 0 1 2 3 4, len: 5
$ unset nums[0]
$ echo "arr: ${nums[@]}, len: ${#nums[@]}"
arr: 1 2 3 4, len: 4
$ echo "nums[0]: ${nums[0]}, nums[1]: ${nums[1]}"
nums[0]: , nums[1]: 1
```

**数组的拼接**
- `new_arr=(${arr1[*]} ${arr2[*]})` 即使用解析的方式拼接数组
- 这种拼接方式把所有稀疏值全丢了，然后重新索引
```shell
$ arr1=(0 1 2)
$ arr1[10]=6
$ arr2=(3 4 5)
$ arr3=(${arr1[*]} ${arr2[*]})
$ echo ${arr3[*]}
0 1 2 6 3 4 5
$ echo ${arr3[11]}    # 如果不丢稀疏值, 那这里应该显示3

$ echo ${arr3[10]}    # 如果不丢稀疏值, 那这里应该显示6

$ echo ${arr3[3]}     # 丢了稀疏值, 所以这里是6
6
```

**关联数组**
- 这就更像哈希表了，即其键值是字符串

**总结**
- 这东西太奇怪了
# 5.4 数学运算
