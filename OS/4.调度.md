 # 4.1调度的基本概念和三层调度

调度研究如何决定处理一堆任务的顺序

- 作业：指一个具体的任务，如运行程序

## 4.1.1三层调度
1. 高级调度(**作业调度**)
- 按一定的原则从外存的作业后背队列中挑选一个作业调入内存，并创建进程
- 任务开始时创建PCB，任务结束时撤销PCB

2. 低级调度(**进程调度**)
- 按一定的原则从进程就绪队列中挑选一个进程，并上CPU

3. 中级调度(**内存调度**)
- 按一定的原则从处于挂起状态的进程重新调入内存
- 当内存资源不足时，将某些进程的数据调到外存中，等内存有空闲或需要运行时再重新调入内存。**暂时调出的进程状态为挂起状态(Suspend)**，挂起的进程PCB组织成挂起队列

对比：

|    类型      | 动作                                           | 位置       | 发生频率 | 进程状态的改变     |
| -------- | ---------------------------------------------- | ---------- | -------- | ------------------ |
| 高级调度/作业调度 | 从后备队列中选择合适的作业调入内存，并创建进程 | 外存->内存 | 低       | 无->创建态->就绪态 |
| 中级调度/内存调度 | 从挂起队列中选择合适的进程将数据调回内存       | 外存->内存 | 中       | 挂起态->就绪态     |
| 低级调度/进程调度 | 从就绪队列中选择合适的进程为其分配处理机       | 内存->CPU  | 高       | 就绪态->运行态     | 


# 4.2 进程调度的机制

**挑一个进程上CPU干活**：进程调度时按照一定规则从就绪队列中选择一个进程为其分配处理机
**换而言之，重点是挑一个进程干活**，而非令当前进程下CPU或其他的事情

## 4.2.1进程调度的时机

**进程调度会在以下情况发生**
1. 当前进程主动放弃处理机
   - 进程正常地终止
   - 进程运行发生异常而终止
   - 进程主动进入阻塞等待事件发生
2. 当前进程被迫放弃处理机
   - 时间片用完
   - 有更紧急的事件需要处理：如更高优先级的进程加入了处理队列、或IO中断等

**进程调度不在以下情况发生**
1. 进程在OS内核程序临界区中
2. 在运行原语时，操作不可中断，如：
   - 中断处理
   - 进程改变状态

## 4.2.2进程调度的方式

- 非剥夺调度方式/非抢占式：
  只允许进程主动放弃处理机包括：
  1. 进程正常终止
  2. 进程引发异常而终止
  实现简单，系统开销小但是无法及时处理紧急任务
- 剥夺调度式/抢占式:
  还允许：
  1. 使用时间片让进程轮流运行
  2. 中断当前进程而调度优先级更高的进程
  实现复杂


## 4.2.3进程切换

步骤:
1. 保存当前运行进程的上下文至PCB
2. 从PCB恢复调度进程的上下文至寄存器

进程的切换有代价，因为需要花费切换进程


# 4.3调度程序

什么会触发调度程序：
1. 创建新进程
   - 创建新进程会导致就绪队列改变。这就要求OS判断是否要让新的进程上CPU
2. 进程退出
   - 当前进程结束，调度程序就要考虑接下来让哪个进程上处理机
3. 运行进程阻塞
   - 当前进程阻塞，调度程序就要考虑接下来让哪个进程上处理机
4. I/O中断发生
   - 会导致就绪队列发生改变，调度程序就要考虑接下来让哪个进程上处理机
总结：
几种可能导致调度发生：
1. 当OS是非抢占式调度策略，那：
  - 运行中的进程阻塞或退出时
2. 当OS是抢占式调度策略：
  - 运行中的进程阻塞或退出时
  - 时钟中断：由于就绪队列改变，可能有更高优先级的进程将抢占当前进程。CPU就在每个时钟周期或k个时钟周期为单位检查就绪队列，当就绪队列中存在需要抢占的进程时，就触发调度
3. 总结：抢占和非抢占之间的区别在于：调度是否可以在当前进程之外产生

调度程序任务：
1. [调度算法](#4.4调度算法)——让哪个进程运行
   - 当前进程要不要下处理机
   - **如果当前进程要下CPU**，接下来哪个进程下一个上CPU
2. 决定时间片大小——让进程运行多长时间

## 4.3.1空闲进程

空闲进程: Idle Process
- 优先级最低
- 就绪队列为空且没有其他进程占用时执行空闲进程
- 执行一些0地址指令，能耗低

# 4.4|调度算法

## 4.4.1|调度算法评价指标

- <u>由于一个进程在CPU上或IO设备上运行的时间一般是不变的(</u>和其本身的时间复杂度和空间复杂度有关)。
- 调度算法影响的是在进程在CPU外的等待时间，所以评价指标也与等待时间有关

- ==**CPU利用率**==：指CPU处于忙碌的时间占总时间的比例
  CPU利用率越高越好$$C = \frac{T_{busy}}{T_{total}} \times 100\% $$
- ==**系统吞吐量**==：单位时间内完成的作业数量
  吞吐量越高越好(尽可能在短的时间内处理多的作业)$$S = \frac{N_{works}}{T}$$
  - ==**周转时间**==：从作业被提交到完成所花费的时间
    需要注意的是，周转时间不等于运行时间。周转时间还包括等待、阻塞等可观的时间。因此就算两个作业在CPU上运行的时间相同，其周转时间也可能不同，且这种不同能被用户所感知。
    1. $T_{wait}$ 从外存后备队列等待被作业调度的时间
    2. $T_{ready}$ 等待被进程调度的时间
    3. $T_{CPU}$ 在CPU上运行的时间
    4. $T_{I/O}$ 进程等待IO操作的时间
    2, 3, 4三项可能在作业生命周期中多次发生
    $$ \begin{equation}\begin{split}T_{turnover}  & = T_{wait} + T_{ready} +T_{CPU} + T_{I/O}
    \\& = t_{submit} - t_{finish} \end{split}\end{equation}$$
- ==**平均周转时间**==：即每个作业平均需要的周转时间
   $$T_{avg} = \frac{\sum^N_{i = 1} T_i }{N}$$
- ==**带权周转时间**==：作业周转时间与实际运行之比
     显然该比值>1且比值越小用户越满意
     $$T_{weighted} = \frac{T_{turnover}}{T_{CPU}}$$
- ==**等待时间**==：指进程/作业处在等待处理机的时间之和
  1. 即等待作业调度时间加上等待进程调度的时间，不包括IO时间

- ==**响应时间**==：从用户提交请求到首次产生响应所用的时间


## 4.4.2|FCFS算法
**先来先服务(First come first serve)算法**

- 算法思想：从公平角度考虑，先来的/等待时间最久的先服务
- **算法规则：按作业/进程的创建的先后顺序进行服务**
- 调度：
  1. 用于作业调度时：先处理最先到达后备队列的作业
  2. 用于进程调度时：先处理最先到达就绪队列的作业
- 抢占/非抢占式算法 ： **非抢占式算法**
- 优点：公平，算法简单
- 缺点：排在长作业后的短作业带权周转时间很大。**FCFS对长作业有利，对短作业不利** (如排队买奶茶，你买一杯，但是前面那个买100杯)
- 是否会导致饥饿：否


## 4.4.3|SJF算法
**短作业优先(Shortest Job First)算法**

- 算法思想：**追求最少的平均等待时间、平均周转时间、平均带权周转时间**
- 算法规则：最短的(CPU时间)作业/进程优先得到服务
- 调度：
  1. 用于作业调度(shortest job first, SJF)
  2. 用于进程调度(shortest process first, SPF)
- 抢占/非抢占算法：
  1. 一般是非抢占
  2. 抢占版本: Shortest Remaining Time Next, SRTN：**即每个时钟结束后都优先调度CPU剩余时间最小的进程**，抢占式的三个指标比抢占式的一般更小(你要考虑IO)。
- 优点：最短的平均等待时间、平均周转时间、平均带权周转时间
- 缺点：不公平，对短作业有利对长作业不利。且运行时间由用户提供，不一定真实
- 会产生饥饿：当长作业运行时连续有短作业到来，则长作业将长时间得不到服务

## 4.4.4|HRRN算法
**高响应比优先(Highest response ratio next, HRRN)算法**

- 算法思想：综合考虑作业/进程等待时间和要求服务的时间
- 算法规则：每次调度时先计算相应比，选择响应比最高的作业优先服务$$R = \frac{T_{wait} + T_{CPU}}{T_{CPU}} = 1+\frac{T_{wait}}{T_{CPU}}$$
- 调度：
  1. 可用于作业调度
  2. 可用于非作业调度
- 抢占/非抢占：
  - 非抢占：在当前进程主动放弃CPU时，则计算就绪队列中所有进程的响应比，选择最高的先上处理机
- 优点：综合考虑了等待时间和运行时间：
  - 等待时间相同的进程优先执行运行时间短的
  - 运行时间相同的进程优先执行等待时间久的
- 是否会饥饿：否

## 4.4.5|早期批处理系统调度算法总结

由于FCFS, SJF, HRRN算法不考虑优先程度及响应时间，对于用户来说交互性差。因此以上算法一般运用于早期批处理系统

|              | FCFS          | SJF                      | HRRN                        |
| ------------ | ------------- | ------------------------ | --------------------------- |
| 思想         | 先来的先服务  | 运行时间短的先服务       | 综合考虑等待时间和运行时间  |
| 规则         | 按先后顺序    | 按运行时间小到大         | 按等待时间/运行时间从小到大 |
| 是否可抢占   | 否            | 是(SRTN算法)             | 否                          |
| 优点         | 公平,实现简单 | 最短平均等待/周转时间    | 均衡考虑                    |
| 缺点         | 对短作业不利  | 对长作业不利，可导致饥饿 | -                           |
| 是否导致饥饿 | 否            | 是                       | 否                          |

## 4.4.6|时间片轮转调度算法
Round-Robin

- 算法思想：**公平地、轮流地为各个进程服务**，让每个进程在一定的时间间隔内都可以得到响应
- 算法规则：按各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(由OS设定)。若当前进程在时间片内未处理完，仍剥夺处理机并把**该进程放入就绪队列队尾**。也就是说，如果同一时刻，来了各进程又下了各进程，下cpu那个进程还是排队尾的
- 调度
  - 仅用于进程调度：因为时间片仅对进程有效
- 抢占式算法：抢占是由时钟中断引发的
- 时间片大小的选择
	- 时间片如果太大，使得进程以到达先后顺序完成，就会退化为FCFS算法。
	- 时间片如果太小，使得需要频繁进程切换，就会增加时间开销。
	- 一般使得切换进程所需的时间开销不及时间片的1%
- 优点：公平， 响应快，适用于分时操作系统
- 缺点：进程切换会产生开销哦啊，而且不区分任务优先级
- 不会导致饥饿

## 4.4.7|优先级调度算法

- 算法思想：需要根据任务紧急程度来决定处理顺序
- 算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
- 调度：
  - 可用于作业调度
  - 可用于进程调度
  - 可用于I/O调度
- 抢占？
  - 可抢占：**每当就绪队列发生变化时都检查是否进行抢占**
  - 可非抢占：**只在进程主动放弃处理机时进行调度**
- 补充：
  - 有些OS有多个就绪队列，可以按照优先级来组织不同的队列。
  - 有些OS仅支持一个就绪队列，则每次就绪队列发生变化都需要维护就绪队列的优先级顺序
  - 根据优先级是否可以动态改变，可以将优先级分为静态优先级和动态优先级
    - 静态优先级：进程一旦创建优先级就不能改变
    - 动态优先级：进程创建时有一个初始优先级，之后可以根据情况动态调整优先级
- **如何确定进程优先级：**
  - 系统进程优先级高于用户进程
  - 前台进程优先级高于后台进程（用户感知明显的进程应该得到更积极响应）
  - I/O繁忙进程高于CPU繁忙进程（I/O设备可以和CPU并行工作，如果优先令I/O进程运行，则时间利用率和吞吐率会提升）
  - 当动态优先级时：
	  - 当一个进程等待太久可以适当提升优先级
	  - 当一个进程运行太久可以适当降低优先级
	  - 当一个进程频繁进行大规模I/O操作时
- 优点：
  1. 使用优先级区分紧急程度和重要程度，适用于实时操作系统
- 缺点：
  当高优先级进程不断到来则可能导致饥饿
- 可能导致饥饿

## 4.4.8|多级反馈队列调度算法

- 算法思想：对其他调度算法的折中
- 算法规则：
  1. **设置有限的多级就绪队列，数字越小优先级越高，但时间片也越短**
  2. **新进程首先到达1级就绪队列**，使用时间片轮转按FCFS原则调度。
  3. 队列中的进程若**时间片用完但是还未结束，则放入下一级级队尾等待调度。** 若进程处于最后一级队列，时间片结束时则放回最后一级队列的队尾。
  4. **只有1~i级队列为空时，才会调度i+1级队列**
- 调度：
  - 用于进程调度
- 抢占式算法：当1~i级就绪队列加入了新进程，i+1级的进程就会被抢占，下处理机时被放回原就绪队列队尾
- 非抢占式算法：不进行抢占，而是等待当前当前时间片用完再调度高优先级队列
- 优点：
  1. 对各类型进程相对公平(FCFS的结果)
  2. 每个进程能很快得到响应(时间片轮转的结果)
  3. 短进程只用较少时间就能完成(多级优先队列+分级时间片的结果)
  4. 不必估计进程运行时间
  5. 可以灵活调整各类进程的偏好程度：比如在规则3中，当某一类型的进程时间片用完时不是将其放入下级队列，而是放入原先的队列队尾以保证其高优先级
- 是否导致饥饿：会（如果源源不断有新的中等长度进程在一个长进程之后到达）


## 4.4.9|交互式系统调度算法总结
|      | 时间片轮转调度               | 优先级调度               | 多级反馈队列调度                 |
| ---- | ------------------------------ | ------------------------ | ---------------------------- |
| 思想 | 公平地、轮流地服务进程         | 优先处理优先级高进程     | 折中                         |
| 规则 | 进程按先后顺序轮流运行一段时间 | 优先调度高优先级进程     | 多级队列优先调度高优先级队列 |
| 调度 | 进程调度                       | 作业调度/进程调度/IO调度 | 进程调度                     |
| 抢占 | 抢占式                         | 抢占/非抢占              | 一般是抢占                   |
| 优点 | 公平，适合分时系统             | 区分优先级               | 平衡                         |
| 缺点 | 时间片轮转导致的进程切换开销   | 可能导致饥饿             | 可能导致饥饿                 |
| 饥饿     | 否                                |是                          |是                              |
- unix使用的就是多级反馈队列调度系统

## 4.4.10|多级队列调度算法

- 划分多个不同类型的队列如：
  1. 系统进程队列：如内存管理等
  2. 交互式进程队列：如键盘、鼠标等
  3. 批处理进程队列：如渲染、大规模计算等
- 不同的队列可以使用不同的算法调度
- 队列间切换，
  - 可以按照固定优先级的方式： 即高优先级的队列必须先算完再调用第优先级队列
  - 可以按照划分时间片的方式：即将一个时间片按不同比例划分给不同等级的队列