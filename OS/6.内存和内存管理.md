
# 6.1内存基本知识

**==内存==**
- 内存用于**暂时存放程序及CPU的运算数据**
- 程序需要先被调入内存，才能继续被CPU处理

## 6.1.1|内存地址

==**内存地址**==
- 内存被划分成一个个小的储存单元，每个单元有唯一地址索引
- 编址：指计算机对内存地址的编排方式
  1. 按字节编址：
     - 储存单元大小：1Byte
  2. 按字编址
     - 储存单元大小：1Word  字的长度由计算机指定，如16位字、32位字等
- 内存的地址也是由二进制表示的
  - 32位操作系统：内存地址4字节/32位-->$4\times 2^{30}$ 即最多4GB
  - 64位操作系统：内存地址8字节/64位-->$16\times 2^{60}$ 即最多2147483648GB


**==指令参数中的物理地址==**
![[Pasted image 20230620204357.png]]
- 不多说，指令包含指令操作码和参数，操作码能被CPU识别，再根据参数加以计算
- CPU则可以根据参数中的地址作为**物理地址**来找到寄存器和内存位置中的数据
- **物理地址/Physical Address：从0开始，连续自增，不重复**
  1. 每个物理地址是不重复的，且唯一确定的，**全局的**
  2. 每个物理地址都与一个储存单元映射
  

**==逻辑/相对地址==**
1. 由于程序进入内存后**存放的位置是不固定的，因此无法知道程序某个数据的物理地址**
2. 所以可以用逻辑/相对地址来描述某个数据的相对于进程头部的偏移为逻辑地址
![[Pasted image 20230620205215.png]]
- **逻辑地址/Logical Address : 访问指令给出的地址**
  逻辑地址描述的是相对进程对象在内存头部的偏移
  从逻辑地址到物理地址需要进行相互转换
  每个进程的逻辑地址都指向了不同的物理地址

## 6.1.2|程序的编译和运行

**==编译到运行==**
![[Pasted image 20230620212006.png]]


**==链接过程==**
1. **静态链接**：连接时就把所有模块装成一个模块，之后不再拆开，所以**装入模块中已经具有完整逻辑地址**
![[Pasted image 20230620212216.png]]
2. **装入时动态连接**：在各个目标模块装入内存时，边装入边链接。即在装入内存时，一边装入一边计算逻辑地址。
   ![[Pasted image 20230620212503.png]]
3. **运行时动态连接**：在程序运行时需要该模块时，才对其进行连接。便于修改和更新
   ![[Pasted image 20230620212655.png]]

## 6.1.3|装入方式

装入程序是指可处理所有的与指定的基地址或起始地址有关的可重定位的地址的程序。
换而言之，装入程序用于确定写入内存程序中的各种地址
影响：
- 进程中的指令、数据等的地址究竟写的是什么

**==绝对装入==**
- **编译过程：编译时转换为物理地址**
- 装入过程：不对地址操作
- **内存中地址形式：物理地址**
- 只适用于单道程序环境
> 例子
> 如果知道要在内存的100处开始存放，则对所有使用到的地址计算出物理地址，就是100+相对地址   

**==静态重定位==**
- 编译过程：计算相对地址
- **装入过程：转换物理地址后装入**
- **内存中地址形式：物理地址**
- 基于这种方式， 如果无法获得足够的连续内存空间，那装入过程中转换物理地址就会失败。这样就不能装入该作业。
- 装入后，进程就不能在内存中移动或申请更多的内存空间
![[Pasted image 20230620211308.png]]

==**动态重定位**==
- 编译过程：计算相对地址
- 装入过程：不对地址操作
- **内存中地址形式：逻辑地址**
- **需要一个重定位寄存器支持，用来记录模块装入时的起始位置**，以实现逻辑地址到相对地址的转换
- 装入后，允许在内存中移动或申请更多内存空间，内存空间可以不连续


# 6.2内存管理

内存管理包括：
1. **内存空间的分配和回收**
	1. 记录哪些内存位置已经被占用
	2. 为待分配的进程确定内存位置
	3. 如何回收结束的进程
2. 虚拟技术以**从逻辑上对内存空间进行扩充**
3. 地址转换以**提供逻辑地址到物理地址的转换**
4. 内存保护以**保证各进程在各自储存空间内运行，互不干扰**
   - 使用上下限寄存器保证处理当前进程时不越界
   - 使用**重定位寄存器**(存放进程基物理地址)和**界地址寄存器**(存放了进程的最大逻辑地址)进行越界检查

# 6.3内存覆盖与交换


## 6.3.1|内存覆盖

**==产生原因==**
- 当程序的大小大于可用物理内存的总和，使得不可能完整装入内存中

**==覆盖技术==**
- **把程序分为多个段**：
  - 常用段常驻内存(如main)
  - 不常用段只在需要时调入内存(如不可能同时使用的一些模块)
- 主要的思路是：
  - 如果某些模块是不可能同时调用的(如B, C)，那就可以把他们放在同一个覆盖区内
  - 某县模块存在调用关系(如A-B, C-E，等)，就不能放在同一个覆盖区内
![[Pasted image 20230621195117.png]]

**==内存中的区==**
1. 固定区：储存常用段，调入后不再调出，除非运行结束
2. 覆盖区：储存不常用段，调用完后

==**问题**==
1. 系统不知道程序的调用结构，因此必须有程序员自己声明
2. 对用户不透明

**因此，内存覆盖技术已经不再使用了**

## 6.3.2|内存交换

==**内存交换技术概述**==
- 当系统内存空间紧张时，将某些进程暂时置于外存
- 用空余内存空间时，把某些挂起的进程调回内存

参考[中级/内存调度](4.调度#4.1.1三层调度)及挂起
![[Pasted image 20230621200441.png]]

**==调至外存过程==**：
1. 选择可以挂起的进程
2. 在挂起进程的PCB中记录导出至外存的位置
3. **将挂起进程的程序段、数据段保存至外存**
4. 挂起进程的PCB加入挂起队列

注意，PCB常驻内存，不会换出到外存

==**交换技术具体实现**==
-  交换至外存的位置：
   通常把磁盘空间分为文件区和对换区。
   1. **文件区使用非连续的、离散的空间分配方式。** 可以高效利用空间，但读取性能差。
   2. **交换区使用连续的分配方式。** <u>具有更高效的IO效率</u>。相比起文件区，交换区很小。
- 交换的时机：
  1. 当内存负荷高时，可以换出一些进程。当负荷降低时回写。
- 换出的进程：
  1. 优先级低的进程
  2. 阻塞进程
  3. 内存中驻留的时间很长

## 6.2.3|覆盖和交换的区别

| 技术 | 作用域             | 对系统的透明度 |
| ---- | ------------------ | -------------- |
| 覆盖 | 单个进程的内存空间 | 不透明         |
| 交换     | 整个内存空间                    |透明                |


# 6.3内存空间分配和回收

==**内存碎片**==
1. 内部碎片：已分配给进程的内存空间中，存在没有使用的部分
2. 外部碎片：整个内存空间中存在过小的空闲区导致该区无法被使用
   解决方法：使用紧凑技术，使用换入/换出将已分配区尽量聚合到一起


## 6.3.1|连续分配管理方式
- 用户进程内存空间：连续的

包括：
1. [单一连续分配](#6.3.2|单一连续分配)
2. [固定分区分配](#6.3.3|固定分区分配)
3. [动态分区分配](#6.3.4|动态分区分配)

## 6.3.2|单一连续分配

==**分区的划分方式**==
- 内存被分为系统区、用户区
- 系统区放在内存低地址部分，存放用户进程相关数据
- **内存中只能有一道用户程序，用户程序占据整个用户区**
![[Pasted image 20230626200928.png]]
**碎片问题**：
可能有内部碎片

## 6.3.3|固定分区分配

==**分区的划分方式**==：
- 将用户区划分成若干分配后大小不改变的区域
  1. 每个分区大小一致：适合运行多个内存消耗相似的进程
  2. 每个分区大小不一致：适合运行多个申请内存消耗不一的进程
- **每个分区只能放一个程序**
![[Pasted image 20230626203336.png]]

- **==分区说明表==**，包括分区大小、起始地址、分配状态等

| 区号 | 起始地址 | 大小 | 状态   |
| ---- | -------- | ---- | ------ |
| 1    | 8        | 2    | 未分配 |
| 2    | 10       | 2    | 已分配 |
| 3    | 12       | 4    | 未分配 |
| ...     |          |      |        |

- 优点：实现简单、无外部碎片
- 缺点：
  1. 当进程申请超过最大内存分区时，则需要使用覆盖技术。降低性能
  2. 产生分区碎片，内存利用率低。
**碎片问题**
可能有内部碎片


## 6.3.4|动态分区分配

**==分区的划分方式==**
- 不预先划分内存分区
- **在装入过程中决定进程内存分区位置和大小**
- 存在[外部碎片](#6.3内存空间分配和回收)的情况

**==记录方式==**
1. 空闲分区表：记录分区号、起始地址、大小、状态
2. 空闲分区链：记录本分区大小及前一个分区和后一个分区的指针

==**回收内存的表更新方式**==

| 情况 | 前方   | 后方   | 做法                       |
| ---- | ------ | ------ | -------------------------- |
| 1    | 空闲区 | 已分配 | 将回收内存与前方空闲区合并 |
| 2    | 已分配 | 空闲区 | 将回收内存与后方空闲区合并 |
| 3    | 空闲区 | 空闲区 | 合并前后片区及回收内存片区 |
| 4     | 已分配        | 已分配        | 以回收片区创建新的空闲区                            |


动态分配算法：

### 6.3.4.1|首次适应算法
**==思想==**
**优先使用低地址分区**

对于查找分区
- 从低地址开始找，找到首个大于请求分区大小的空闲分区，让它作为载入位置

### 6.3.4.2|最小适应算法
**==思想==**
**优先使用空闲区较小的分区**，以留下空闲区较大的分区供大内存占用进程使用

**==实现方式==**
令空闲分区表以从小到达的方式组织，从小到大寻找载入分区

**==缺点==**
由于每次都选最小的分区进行分配，可能最后会留下许多越来越小的内存块，产生外部碎片

### 6.3.4.3|最大适应算法
**==思想==**
**优先使用空闲区较大的分区**，使得分配后的剩余空闲区不会太小

**==实现方式==**
令空闲分区表以从小到达的方式组织，从大到小寻找载入分区

**==缺点==**
对大内存占用进程不友好，可能导致无满足分区可用


### 6.3.4.4|邻近适应算法
**==思想==**
**优先从上次分配的空闲区附近寻找**

**==实现方式==**
把空闲分区表按照地址以环形链表的方式排列，从上次分配的位置开始(包括自身)寻找。

**==缺点==**
高地址大分区可能被用掉

### 6.3.4.5|总结

![[Pasted image 20230710204135.png]]

# 6.4分页存储管理
首先，分页存储管理技术是***一种非连续内存分配方式***
![[Pasted image 20230711155829.png]]

**==思想==**
把内存空间分为一个个大小相等的分区，每个分区占用一串连续的内存空间

**==分区==**
内存空间中某一片连续的地址位置，如4KB


## 6.4.1|页框、页面和页表

**==页框 / Page Frame==**
- 页框描述的是**物理上的**内存连续片区
- 每个物理分区是一个**页框**，页框=页帧=内存块=物理页面=物理块号。
- 页框号从0开始

**==页 / 页面 / Page==**
- 页/页面描述的是**进程内存空间**的连续片区
- **页面大小应与页框大小相同**
- 每个部分为"页"或“页面”
- 每个进程空间中，页面也有相应的页号，从程序头的0开始。

**==页和页框的关系==**
- 页和页框大小相同
- 页框对应物理地址，页对应逻辑地址
- 页和页框存在一一对应的关系(就是一个页不会在多个页框中，一个页框也不会包含多个页)
- 同一进程的页不一定连续存放，但页框是连续的

**==页表 / Page Table==**
- ***内存空间逻辑地址页号到物理页框号的映射***
- 保存位置：进程PCB
- 用于确定进程的页面分别在哪里，要为进程创建一张页表
![[Pasted image 20230712165626.png]]
- 页表的页号栏：不占内存，默认是0~N，只需按顺序存储页框号即可
- 页表的页框号栏：要计算整个物理内存中有多少个页框，并根据数量决定。记住单位是字节，而不是位，所以存在向上取整的过程


## 6.4.2|地址转换的算法

问题：如何找到指令中逻辑地址对应的物理地址
1. 指令中存放的是逻辑地址
2. 进程的页面可能存放在不同的内存位置，且存放的位置可能不连续，甚至颠倒
3. 页面内的指令、数据等东西逻辑、物理上是连续且按顺序排好的


**==步骤==**
- 根据页面大小，**把==逻辑地址==拆分成页面号和相对偏移量**
![[Pasted image 20230712201149.png]]
1. 计算逻辑地址对应页号: `PageNum = ptr_Log // PageSize;`
2. 通过页表找到对应页面基地址`ptr_PageBase = PageTable[PageNum] * PageSize`
3. 根据偏移找到对应的物理地址`ptr_Phy = ptr_PageBase + ptr_Log % PageSize`

如果系统使用的页面大小是$2^8, 2^{16}, 2^{24}, 2^{32},...B$ ，则逻辑地址最低的几个字节就是偏移量，其余字节能表示页框号，就不用很多计算步骤，拆分分页号和计算相对偏移量会很简单

## 6.4.3|基本地址变换机构

**将逻辑地址转换为物理地址的硬件及算法**

**==页表寄存器 / PTR==**
- 存放页表在内存的物理起始地址F和页表长度
- 进程被调度时会页表起始地址和页表长度被操作系统内核放入页表寄存器中


**==转换过程==**
1. 进程调度，将PCB中的页表导入页表寄存器PTR中
2. 执行指令，取得进程指令中的一条逻辑地址
3. **将逻辑地址拆分**成 页号、页内偏移量
4. **进行越界中断判断**：页号是否超出页表长度
   - 由于页表是按顺序排列的，页表多长就有多少个页面
   - *当逻辑地址解析的页号比页表长度长，显然知道该逻辑地址不合法*，抛出越界中断
5. 通过页表找到页面的页框号，再计算出页框基地址，再**计算出对应物理地址**

```cpp
int* ptr_Logstic;
int* PageSize;
int** PageTable;

// Step 1. Load PageTable to PTR
PTR = PageTable

// Step 2. Divide logistic address to page num and shift in the page. 
int PageNum = ptr_Logistic / PageSize;
int ShiftNum = ptr_Logistic % PageSize;

// Step 3. Out of Bound Interruption 
if(PageNum >= size(PTR))
{
	raise Exception.
}

// Step 4. Calculate the Physical Address.
int* ptr_Physical = PTR[PageNum]*PageSize + ShiftNum;
```

### 6.4.3.1|页表项长度

Fact:
- 页框大小固定
- 页表是存放在页框中的
- 页表项是存放再页表中的，页表项保存的是页框号
- 也就是说**页表项是存放在一个页框中的**
- 如果**页框大小无法整除页表项长度，就会引发问题**

- 如果页框大小为1KB, 页表项长度为4B，那么一个页框内可以放256个页表项
- 然而如果页表项长度为3B，那一个页框大小无法整除页表项长度，造成冗余
- 现在考虑一进程共使用500个页表，如果每个页表项为3B，首个页框能存放341个页表项，但是冗余1B的空间。由于一个页框只能被一个进程占用，所以不能使用这个页框的1B和下一个页框的2B空间作为页表项。
- 然而，页表的逻辑就是连续且有序递增的，冗余的空间会引发异常！

**解决办法：让页框大小恰能整除页表项大小，如使页表项长度为$2^n B$**，比如4B， 8B等

## 6.4.4|使用快表的地址变换机构

基本地址变换机构特点：
1. 依托于页表(在内存中，被称为慢表)
2. **转换过程中查询两次内存**，一次是从页表取页框号，一次是取对应物理内存

快表的改进：
1. 依托于存放在高速缓存中的页表副本(快表)及内存中的页表(慢表)
2. **查页框号时优先查询快表，在命中时显著减少转换时间**

**==储存器价格和速度==**
- 
  ![[Pasted image 20230713164623.png]]

**==快表 / Translation Lookaside Buffer, TLB==**
- TLB是一种硬件机构
- 又称为联想寄存器，一种访问速度比内存快很多的**高速缓存**
- 用于存放最近访问的页表的<u>一部分副本</u>
- **每次进程调度，TLB都会发生清零**

**==快表变换机构的工作原理==**
1. 快表位置在高速缓存，速度比内存快很多
2. 将访问过的慢表(页号-内存块号)保存到快表中
3. 逻辑地址到物理地址的**转换过程中，优先查询快表，不命中再查询慢表**

**==步骤==**
1. 根据逻辑地址计算页号和偏移量
2. 进行越界中断判断
3. 在快表中查询页号对应的页框号
   - 命中，则立刻得到了页框号
   - 不命中，则在慢表中查询，查询完成后把结果保存到TLB。若快表满，则用一定算法丢弃里面的某些页表项，并存放刚刚查询的结果。
4. 根据页框号和偏移量计算物理地址

**==快表与局部性原理==**
- 时间局部性原理：程序设计中，经常会在短时间内多次访问某个数据，或某个条指令
- 空间局部性原理：程序设计中，经常会在短时间内访问相邻的数据或指令
- 由于快表在第一次转换该页面内部的逻辑地址时，保存了对应的页框号，使得频繁访问该页面的时候能多次命中，极大减少慢表访问次数


## 6.4.5|两级页表

### 6.4.5.1|单级页表的问题

单级页表的Fact1:
1. 一个进程可能需要大量内存空间，即需要大量页面
2. 完成页面-页框号映射的是页表
3. 需要大量页面意味着页表有大量页表项，意味着页表可能无法用一个页框存放完
4. 当页表需要大量页框，而系统又无法分配足够数量的连续页框时，就会引发问题
-----> 当页表很大时，单级页表不灵活

单级页表的Fact2:
1. 由局部性原理，一个进程相同时间内使用的页表数量有限
2. 但是单级页表机制会把整个页表载入内存
----> 全部导入页表的优势不大


### 6.4.5.2|使用多级页表离散化页表储存

**==页目录表 / Page Directory Entry, PDE==**
1. 页目录表储存了页表分段的页框号
2. 页目录表的表项为某一页表分段所在的页框号
3. 某一页表分段的表项为某一逻辑地址范围的页框号

| 类型         | 存放内容               | 使用索引    |
| ------------ | ---------------------- | --- |
| 顶级页表     | 页表分段的页框号       | 逻辑地址前几位    |
| 最后一级页表 | 进程页面的页框号       | 逻辑地址中间几位    |
| 页面         | 进程使用的指令、数据等 |逻辑地址最后几位/页内偏移量     |


假设系统32位，页框大小4KB，则逻辑地址的划分为:

| 31 ... 22 | 21 ... 12 | 11...0 |
| --------- | --------- | ------ |
| 一级页号          | 二级页号           | 页内偏移量        |
![[Pasted image 20230714155417.png]]

**==处理步骤==**
1. 把虚拟地址拆分成3段
2. 第一段作为索引可以在顶级页表中查找页表分段对应的页框号
3. 第二段作为索引可以在页表分段中查找对应页面的页框号
4. 找到页面所在物理地址结合页内偏移量计算出物理地址

### 6.4.5.3|使用虚拟储存技术虚拟化页表储存

虚拟化：仅在需要时才把数据调入内存，不需要时置于外存

**==核心==**
- 在多级页表表项中增加一个标志位，用以指示其对应的页表是否已经导入内存，如:

| 一级页号 | 页框号 | 是否在内存中 |
| -------- | ------ | ------------ |
| 0        | 0x0001 | 1            |
| 1        | 0x004  | 1            |
| 2         | 0x00A        |0              |

**==缺页中断==**
当想访问的对象不在内存中时，引发缺页中断(内中断)。需要等待系统把页面调入内存中。


# 6.5基本分段储存管理

## 6.5.1|分段

- 比如一个进程A，有Main函数、函数`func1`, `func2`, ....
- 低级语言会**把每个函数作为一个段**
- 每个段具有一个段名，**每段对应的进程空间连续，段间的内存空间可能不相邻**

**==逻辑地址的分段==**：

| 31 ...... 16 | 15 ...... 0 |
| ------------ | ----------- |
| 段号             | 段内地址             |
- 段号长度决定了进程能有几个段
- 段内地址长度决定了段的最大长度


**==段表==**
1. **把段和段的地址映射起来**
2. 储存位置为进程PCB
3. 段表项包括：段号(隐含)、**段长度**、基地址
4. 段表项总长度是固定的。
5. **注意，分页的页大小是固定的，但是分段的段长不是固定的，只是有一个上限值**

## 6.5.2|分段的地址变换

**==过程==**
1. 调度时，先把进程段表从PCB中导入到段表寄存器中
2. 从逻辑地址中得到段号、段内地址
3. **检查段号是否大于段表长度，判断是否引发越界中断**
4. 从段表寄存器查询段号对应的段表地址、段表长度
5. **检查段内地址和段表长度，判断是否引发越界中断**
6. 确定物理地址
- **注意，由于段长度不一，所以除了判断段号是否越界 ，也需要判断段内地址是否越界**

## 6.5.3|分段和分页的区别

| 类别       | 分页                 | 分段                                                 |
| ---------- | -------------------- | ---------------------------------------------------- |
| 性质       | 信息的物理单位       | 信息的逻辑单位                                       |
| 用户可见性 | 对用户不可见         | 对用户可见                                           |
| 行为所属   | 系统行为             | 用户编程时的行为                                     |
| 大小       | 页大小固定           | 段大小不固定                                         |
| 表内容     | 页表存页框号         | 段表存段长和基地址                                   |
| 进程共享   | 不能实现进程间页共享 | 通过段表实现进程间段共享(因为段的逻辑是完整、独立的) |
| 碎片           | 内部碎片                      |外部碎片                                                      |

# 6.6段页式存储管理

**==思想==**
- 以程序逻辑为段，段映射到分页
![[Pasted image 20230718112217.png]]

**==逻辑地址结构==**
- 由于要先分段，再分页，再寻址，所以逻辑地址结构包括了三个部分

| 31      ...     16 | 15  ...   12 | 11   ...   0 |
| ------------------ | ------------ | ------------ |
| 段号               | 页号         | 页内偏移量   | 
- 段号长度决定了能有几个段
- 页号长度决定了一个段最多能有几个页
- 页内偏移量决定了页的大小

---
**==段表==**
- 段表完成段号到段的映射
- 段表内容为对应段的页表
- 由于段是按照分页储存的，所以段可以用页表表示

**==页表==**
- 页表完成段到段的页的映射

# 6.7虚拟内存

**==传统方式的缺点==**：
1. 作业很大时，可能无法装入。导致无法运行
2. 大量作业需要运行时，实际能存放的作业数量有限，使并发性下降
3. 作业一旦装入内存就会一直驻留内存直到作业完成。并发时内存中有很多暂时用不到的数据

**==局部性原理：==**
1. 时间局部性：当前指令可能不久后会被再次执行
2. 空间局部性：某个存储单元被访问后，其邻近单元可能不久后会被再次访问

**==虚拟内存技术：==**
1. 将程序很**快要使用到的部分装入内存，暂时用不到的留在外存**
2. 运行时发现所需的页不再内存时，从外存调入内存
3. 内存空间不足时，把暂时用不到的换出到外存
4. 由此，系统能使用一个较大的内存资源空间

**==特点==**
1. 多次性：一个作业可以分多次调入内存
2. 对换性：作业运行时不一定会常驻内存，而是允许作业换入换出
3. 虚拟性：从逻辑上扩充了内存容量

