
# 2.1进程的概念、组成和特征

## 2.1.1进程的概念

程序VS进程:
- 程序：是一系列指令的集合储存在磁盘中，是静态的。
- 进程(Process)：是[进程实体](#2.1.2.2进程实体的组成)的运行过程，是OS进行资源分配和 调度(操作系统决定让哪个进程在CPU上运行)的一个独立单位。OS就是以进程为单位，为其分配各种内存、CPU等资源的。
- 同一个程序，同时多次运行就会产生多个进程，比如双开QQ

## 2.1.2进程的组成

### 2.1.2.1进程控制块PCB

==**PCB的概念**==
系统需要记录进程的许多信息，这些数据被保存至特别的数据结构PCB（Process Control Block）中。PCB中的信息被用于进程的管理。

- <b><i><u>进程生命周期中， PCB是进程存在的唯一标志。</u></i></b>当进程被创建时，PCB也同时被创建。当进程结束时，PCB被系统回收。因此PCB在，进程就在。
- PCB被储存在内存中

==**PCB的组成**== : PCB包含对进程进行管理的所需信息
1. 进程的描述信息
   1. 进程标识符(Process ID, PID)：进程被创建时，OS会为其分配一个**唯一的、不重复的ID以示标识**。
      - PID只要被使用过，就不会再被分配给其他进程。
      - PID被用于识别不同的进程
   2. 用户标识符(User ID, UID)
2. 进程控制和管理信息
3. 资源分配清单
4. 处理机相关信息

### 2.1.2.2进程实体的组成
![[Pasted image 20230505153505.png]]

对于一个exe可执行文件，运行产生了一个进程实体：
1. OS为其创建PCB储存在内存中
2. exe文件的指令被存放在该进程实体(进程映像)的程序段中，CPU可以从中取出指令并运行
3. 进程运行过程中的数据、变量被存放在进程实体的数据段中

因此，在进程实体的组成中，PCB用于OS作进程管理用。而程序段和数据段为程序自身运行用。



## 2.1.3 进程的特征
![[Pasted image 20230505154641.png]]



# 2.2进程的状态与转换

## 2.2.1进程五状态及转换

PCB中有一个变量`state`用于储存进程的状态

1. **创建态/新建态New：进程正在被创建**
   - OS初始化PCB，分配资源，将程序读入程序段
2. **就绪态/Ready：进程等待CPU响应**
   - 创建完的进程进入就绪态
   - 运行态的进程，在时分复用中已经用完自己的时间片
   - 阻塞态的进程等待的事件发生了
   - OS中可能有多个进程处于就绪态
3. **运行态/Running：进程在CPU上运行时**
4. **阻塞态/等待态/Blocked：进程运行至需要等待某个事件的发生时**
   - 如通过系统调用请求一个正忙的资源
   - 或等待其他进程的响应时
   - OS会让该进程下CPU，并进入阻塞态
   - 当等待的事件发生后，**CPU会主动让**进程回到就绪态
5. **终止态/Terminated：进程结束的状态**
   - 进程执行`exit`系统调用，请求OS终止该进程。
   - CPU会回收内存空间及PCB

![[Pasted image 20230509101851.png]]

## 2.2.2进程的组织

OS是如何将各个进程的PCB组织起来的

**链式方式**：
- 大部分OS均使用这种方式
- 不同态队列有着不同的指针。
- 就绪态按照优先级别排列指针
- 阻塞态根据阻塞原因排列队列
![[Pasted image 20230509102236.png]]

**索引方式**：

![[Pasted image 20230509102939.png]]
# 2.3进程的控制

即**实现**进程状态的切换
1. 需要将PCB state切换
2. 将PCB加入合适的队列中

### 2.3.1如何实现进程状态转换

这个过程，必须保证“原子性”，即1和2要一气呵成不间断执行，才能保证每个态的队列中PCB的state是统一正确的。
可以使用[原语](1.操作系统的概念#操作系统内核)来完成！

关于[中断机制](1.操作系统的概念#中断类型)，CPU每执行一条语句后都会检查有没有外中断信号
- 原语(内核程序)：
  具有特权指令：关中断指令和开中断指令
  1. 原语运行时，在执行关中断指令后不会再例行检查中断信号，直到开中断指令执行

### 2.3.2创建原语：
OS创建一个进程时使用的原语
发生条件：
- 用户登录：分时系统中用户登录成功
- 作业调度：多道批处理系统中新作业放入内存时
- 提供服务：用户进程使用系统调度申请某些服务时
- 应用请求：用户进程请求创建一个子进程
- ...

步骤：
1. 申请空白PCB
2. 为新进程分配所需资源
3. 初始化PCB
4. 将PCB插入就绪队列

### 2.3.3撤销原语
OS终止一个进程时使用的原语
发生条件：
- 正常结束：进程自己请求终止(exit 系统调用)
- 异常结束：异常导致的中断
- 外界干预：用户选择终止进程

步骤：
1. 在PCB集合中找到需要终止的PCB
2. 若进程正在运行，立刻剥夺CPU资源，将CPU分配给其他进程
3. 终止该进程所有子进程
4. 将该进程拥有的资源归还给父进程或OS
5. 删除PCB

## 2.3.4阻塞原语
OS让一个进程从运行态转换为阻塞态

发生条件：
- 进程需要等待系统分配某种程序资源
- 需要等待其他进程

步骤：
1. 找到要阻塞的PCB
2. 保护运行现场，将PCB状态信息设置为阻塞态，下CPU
3. 将PCB插入相应事件的等待队列

## 2.3.5唤醒原语
OS让一个进程从阻塞态转换为就绪态

发生条件：
- 阻塞态等待的事件发生

步骤：
1. 从对应事件的等待队列中找到PCB
2. 将PCB从等待队列中移除，设置其PCB状态为就绪态
3. 将PCB插入就绪队列等待被调度

## 2.3.6切换原语
OS让进程在就绪态和运行态之间切换

发生条件：
- 当前进程时间片到
- 有更高优先级进程到达
- 当前进程主动阻塞
- 当前进程终止

步骤：
1. 将上下文存入PCB
2. PCB移入相应队列
3. 选择另一个进程执行，并更新其PCB
4. 根据PCB恢复新进程所需上下文

### 2.3.6.1进程运行的上下文(context)

CPU设置很多寄存器，来描述当前运行状态如：
- PSW / 程序状态字寄存器：记录当前CPU状态为内核态/用户态
- **IR / 指令寄存器：存放当前正在执行的指令**
- **PC / 程序计数器：存放下一条指令的地址**
- **通用寄存器：** 在进程运行过程中，会将内存中的数据读入CPU中的寄存器操作，操作完了再写回到内存中

当进程需要转换时，需要保存的环境就是例如IR，PC，通用寄存器等内容。这些寄存器中的值会保存到PCB中，在再次调用的时候就能恢复到之前的运行状态。

# 2.4进程间通信

==Inter-Process Communcation / IPC 定义==：
指两个进程之间产生数据交互

## 2.4.1IPC的实现
- 由于OS为进程分分配空间时，两个不同的进程内存是相互独立的，因此无法直接沟通
- 要实现IPC必须要借助OS的帮助

### 共享存储

基于
- 当OS支持时，**进程可以申请共享存储区**，一些进程就可以一起使用该片内存。
- OS应令各个进程对共享空间的访问是互斥的，进程可以使用OS内核提供的同步互斥工具来实现互斥访问
> linux:
```
int shm_open(..); // shm_open()系统调用，可以申请共享内存区
void *mmap(..); //mmap()系统调用，将共享内存区映射到进程自己的地址空间
```

两种共享方式
1. 基于数据结构的共享：共享区只能放一个特定长度的数据（如一个int，一个结构体etc）。这种共享方式速度慢，限制多，是低级通信方式。
2. 基于储存区的共享：共享区可以放任意东西，数据的形式、存放位置均由通信进程控制而非OS控制。速度快，是高级通信方式。

### 消息传递

进程之间的数据交换以格式化的消息为单位(Message)。进程通过OS提供的发送/接受消息两个**原语**进行数据交换。

消息的结构：
1. 消息头：
   - 发送进程PID
   - 接受进程PID
   - 消息长度等格式化信息
2. 消息体

消息的传递方式
1. 直接通信方式：发送进程指明接收进程的ID
   - 进程PCB中有一消息队列，是
   1. 发信进程S在自己的内存空间中建立并完善消息
   2. 发信进程S系统调用发送原语`send(PID_R, message)`
   3. 发信进程S的消息被挂载到收信进程R的消息队列中
   4. 收信进程R系统调用接受原语`recieve(PID_S, &message)`，当消息队列中存在由S发送的消息时，则复制到R的内存空间中
2. 间接通信方式：以中间实体进行消息传递
   - 信箱作为中间实体，多个进程可以往同一个信箱中发送信息，也可以多个进程从同一个信箱中接受信息。

### 管道通信

管道的通信是单向的
![[Pasted image 20230511150543.png]]

- pipe文件是内存中一片大小固定的缓存
- 需要向OS申请pipe
- pipe的读取是先进先出的(FIFO)
- pipe和共享内存的区别
  1. pipe的读取是FIFO，但共享内存的读取是没有限制的
  2. pipe本质是一个循环队列

- pipe只能采用半双工通信(同一时间段内只能实现单向传输)。要实现全双工通信(双向同时通信)，则需要分别设置两个管道
- 各进程需要互斥地访问管道
- (由于管道有固定大小)管道写满时，写进程被阻塞，直到读进程将管道中的数据取走，使管道非满再唤醒
- 管道为空时，读进程被阻塞，直到写进程开始写数据使管道非空再唤醒

- 问题：管道数据一旦被读取，就会消失。如果管道有多个读写进程，则会造成混乱，因为管道数据没有说是给谁的！

