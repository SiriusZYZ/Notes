
# 3.1线程定义

有的进程可能需要“同时”执行很多事情，但一个进程如果只能穿行地执行一系列程序，则不能满足要求。为此，引入了线程来增加并发度。

- 在同一个进程中可以存在多个线程，每个线程都可以执行自己的任务
- 线程是基本的CPU执行/调度单元
- 线程成为了程序执行流的最小单位
- 进程仍是CPU进行资源分配的最小单元

![[Pasted image 20230515194825.png]]


## 3.1.1进程的属性

![[Pasted image 20230515194859.png]]

# 3.2线程的实现方式

## 3.2.1实现方式

==**用户级线程**==
- 用户级线程可以理解为代码逻辑的载体
- 在不支持线程的早起系统中，通过在同一个进程中使用while循环来模拟“线程”的并发执行。如：
![[Pasted image 20230515200815.png]]
- 在进程中，程序员通过使用线程库，实现线程创建、销毁、调度等功能。
- 因此线程的管理也由进程自己来完成，线程切换也不需要CPU干涉，CPU也无法意识到线程存在

优点：
1. 线程切换在用户空间就能完成，不需要切换CPU状态。
2. 线程管理系统开销小，易于维护

缺点：
1. 由于进程中的任何一个“线程”阻塞，进程也会阻塞，所以就容易导致其他“线程”也没办法运行。因此并发度不高
2. 无法在多核处理机上并行运行线程


==**内核级线程**==
- 内核级线程可以理解为调度分配单位的载体
![[Pasted image 20230515202607.png]]
- OS系统层面上支持线程，线程由OS进行管理
- 线程的切换需要CPU状态转换

优点：
1. 当进程某个线程被阻塞，其他线程还可以运行。并发能力强。
2. 多线程可以在多核处理机上并行执行
缺点：
1. 当一个进程占用多个内核线程，其切换就需要OS完成，管理成本高开销大


**==混合模型==**
- 一对一模型：一个用户线程对应一个内核线程
  - 当一个进程的线程被阻塞以后，其其他的线程还能继续运行，也可以多核运行
  - 但成本高
- 多对一模型：多个用户线程对应一个内核线程
  - 相当于用户级多线程，优缺点相似
- 多对多模型：多个用户线程对应多个内核线程，通过线程库实现内核线程对应
  - 克服了多对一并发度低的问题，也克服了一对一线程管理开销大的问题


# 3.3线程的状态与转换

与[进程的状态与转换](2.进程.md#2.2进程的状态与转换)相似
![[Pasted image 20230518200347.png]]
## 3.3.1线程的组织与控制

**==TCB : ==**
线程TCB与进程PCB相似
TCB内容：
- 线程标识符 / Thread ID / TID : 用于唯一标识线程
- 上下文：在线程切换的时候进行保存/恢复
	- 程序计数器 / Program Counter / PC：用于保存线程当前执行位置
	- 其他通用寄存器的内容：保存运行的中间结果
	- 堆栈指针：指向保存函数调用信息及局部变量等堆栈的**指针**
- 线程运行状态：运行/就绪/阻塞
- 优先级：线程调度和资源分配用的参考

**==组织：==**
- 与进程的组织相似，系统维护线程的TCB队列，考虑不同资源的等待。 



