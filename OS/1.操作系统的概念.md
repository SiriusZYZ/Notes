# 1 操作系统的基本概念

## OS的概念

![[Pasted image 20230419123502.png]]
操作系统:
- 控制和管理整个计算机系统的**硬件和软件资源**
- 合理调度计算机的**工作与资源的分配**
- 提供用户及其他软件方便的**接口与环境**
- 是计算机系统中最基本的系统**软件** (OS是软件)

![[Pasted image 20230419123851.png]]
## OS的功能和目标

1. OS管理以下系统/硬件资源, 目标是安全、高效
  - CPU的资源
  - 内存的资源
  - 文件的资源
  - 设备(如键盘、视频、磁盘)等

2. OS管理以下软件资源，目标是方便用户使用：
  - 用户接口
     - 命令接口:  允许用户**直接使用**
       - 联机命令/交互式命令接口: 相当于cmd，即交互式的。用户说一句，系统做一句。
       - 脱机命令/批处理命令接口: 相当于.bat文件。用户说一堆，系统做一堆。
     - 程序接口/<u>系统调用</u>：允许用户通过程序**间接使用**
       - 如dll文件，只可以通过程序调用dll (称为系统调用)，但用户不能直接使用dll
 - GUI: 图形用户接口
  - 在形象的图形界面进行操作，不需要使用复杂的指令等就能完成任务(如把文件拖到垃圾桶就是删除)

3. OS实现对硬件机器的拓展
   - 没有任何软件支持的纯硬件被称为裸机
   - 覆盖了软件支持的机器为扩充机器，或称为虚拟机
   - 安装了操作系统的扩充机器可以提供资源和任务管理功能，为用户提供服务

## OS的特征

1. ==并发==：两个或多个事件在**同一时间间隔**(<u>注意是时间间隔而不是时刻</u>)内发生。
   - **宏观上：同时发生**
   - **微观上：交替发生**
   - 注意和并行区分，**并行是同一时刻发生**，比如GPU提供并行运算，CPU提供并发运算
   - OS的并发性：由于一个CPU同一时刻只能执行一个程序，所以操作系统会协调多个程序交替运行
2. ==共享==：资源共享，指系统中的资源可以提供给多个并发执行的进程同时使用
   - 两种资源共享模式:
     1. 互斥共享：一个时间段只允许一个进程访问该资源
        如同一时刻摄像头只能分配给一个进程
     2. 同时共享的方式：一个时间段由多个进程“宏观上同时”对其进行访问。
        如通过不同软件同时读取同一个文件
- 并发需要依托共享(因为可能需要同时使用设备/资源)来实现，而共享在没有并发时则没有意义
3. 虚拟：把物理上的实体映射成若干个逻辑上的对应物，前者实际存在，后者用户能感知存在
   > 如虚拟内存(空分复用)
   > 虚拟处理器(时分复用)
4. 异步：多个进程并发运行时，由于资源有限，进程执行不是一贯到底而是走走停停的，**以不可预知的速度向前推进**
   > 例如，当某个进程占用了一个互斥共享的资源，而另一个进程想调用这个资源，后来的进程就会被阻塞，只有等前者用完了才能开始，这就显示了资源有限导致进程执行无法一贯到底进行
   
并发与共享是OS两个最基本的特征，两者相互依存。而没有并发和共享，系统就谈不上虚拟和异步。

## 操作系统的发展与分类

1.  手工操作阶段：
   用纸带作为程序和参数，输入到计算机中。返回时也是纸带打孔。问题是输入输出占用时间比运算时间多得多
2.  单道批处理系统：
   每次将多个程序导入磁带，磁带上有设备可以进行分配任务，每次放一个任务到CPU中。开始有监督程序负责控制作业的输入和输出，监督程序就是操作系统的雏形
3. 多道批处理系统：
   多个程序导入磁带，磁带上有设备进行分配任务，把多个任务放到CPU中，并发处理。引入了中断技术，此时允许多个程序进行并发运算读写，操作系统出现。
4. 分时操作系统:
   计算机按照时间片为单位轮流为各个用户/作业服务，用户可以利用终端与计算机交互。
5. 实时操作系统：
   比分时可以提供优先级


## 操作系统的运行机制和体系结构

![[Pasted image 20230424213222.png]]

### 运行机制
   - 指令：即机器语言指令，CPU能识别、执行的命令
     1. 特权指令：不允许用户程序使用(如内存清理指令，)
     2. 非特权指令：允许用户程序使用(如加减法)
   - 处理器状态：
     - 通过程序状态字寄存器(PSW)某个标志位来标记当前处理器处于什么状态
     1. 用户态(目态)：CPU只能执行非特权指令
     2. 核心态(管态)：CPU可以执行特权及非特权指令
   -  两种程序:
     1. 内核程序：OS内核程序运行在核心态，是系统的管理者，可以执行特权/非特权指令
     2. 应用程序：运行在用户态只能执行非特权指令

### 操作系统内核
是计算机配置的底层软件
   - 在OS中还分为非内核功能和内核功能
   - 内核功能中
     - 内核功能运行在核心态
     1. 有一些是直接面向硬件的，如
        - 时钟：计时功能
        - 中断：实现中断机制
        - 原语：位于OS最底层，最接近硬件，是一种特殊的程序，运行时间短但频繁，一旦运行不能中断(原子性)。（如设备驱动/CPU切换）。
     2. 另外一些是面向系统资源管理的：进程管理、储存器管理、设备管理等。然而划分不同，这一部分也不同。有些系统认为这些是内核，有些则不认为。

### 操作系统的体系结构：大内核VS微内核
   1. 大内核：
      当内核功能包括上面的1和2。由于包含功能多，结构混乱，维护困难。
   2. 微内核：
      当内核功能只包含上面的2。由于不包含资源管理功能，因此需要经常切换处理器状态，性能低。
![[Pasted image 20230421202109.png]]

## 中断和异常

![[Pasted image 20230424230702.png]]
### 中断的作用

过程:
- ==内核态== CPU上运行内核程序
- ==用户态== OS使用特权指令，修改PSW为用户态，操作系统把CPU使用权让给应用程序，
- ==内核态== “中断”是OS从应用程序中收回CPU使用权的**唯一途径**，在硬件层面完成变态过程

中断机制实现了多道技术并发，能让OS内核强行夺回CPU控制权，且是唯一途径。

### 中断类型

- ==内中断== **(异常)**
  - 来源：中断信号来自**CPU内部**
  - 结果：CPU自动转换为核心态，OS开始运行中断程序
  - 关联：与当前执行的指令有关
    1. Abort / 终止 : 
       - 原因：请求执行的指令产生致命错误
       - 修复性：内核程序无法修复该错误
       - 结果：一般终止(Abort)该程序运行，并进入中断内核程序
       - 例子：
         - CPU通过PSW发现用户程序非法地使用特权指令
         - CPU发现命令参数非法，如除0
    2. Fault / 故障：
       - 原因：请求执行指令具有错误的条件
       - 修复性：可能可以被内核程序修复
       - 结果：在内核程序修复成功后，可能让程序继续执行
       - 例子：
         - 缺页故障
    3. Trap / 陷入：当前用户程序发出“陷入指令”，该指令主动将CPU使用权还给OS，并要求OS运行某些特权指令以提供服务，这是一种“系统调用”
    

- ==外中断== (狭义的中断)
  - 来源：中断信号来自**CPU外部**
  - 关联：与当前执行的指令无关
    1. 时钟中断：
       - 来源：时钟部件
       - 结果：进入内核态，执行时钟中断的内核程序，再进入用户态给其他应用程序使用CPU资源
       - 作用：切换程序，实现多道并发
    2. I/O中断 
       - 来源：输入/输出设备
    ...
 
- CPU执行应用程序命令时，都会判断其是否合法。若不合法则会产生内中断。
- CPU执行完任何命令，都会检查是否有外部中断信号。若有则产生外中断。

### 中断机制基本原理

- 不同的中断信号，使用不同的中断处理程序
- 指向不同中断程序的指针保存在一张中断向量表中，
![[Pasted image 20230424230412.png]]
## 系统调用

系统调用是应用程序请求内核服务的一种途径。
![[Pasted image 20230427165158.png]]
### 库函数与系统调用
- 程序员可以通过使用编程语言的库函数，进行系统调用。一些库函数封装了系统调用的功能。
- 但不是所有库函数都属于系统调用，只有请求内核服务的函数才是

### 系统调用的作用：
- 并发程序请求使用同一个资源时，如果不经系统管理，可能会导致同时读写资源的问题
- 在系统调用时，请求同一个资源会被内核进行管理，从而避免问题

### 系统调用的分类
凡是和共享资源有关的操作，都需要通过系统调用的方式
1. 设备管理：设备的请求/释放/启动等功能
2. 文件管理：文件的I/O 创建、删除等功能
3. 进程管理：进程创建、撤销、阻塞、唤醒等功能
4. 进程通信：进程间消息/信号传递等功能
5. 内存管理：内存分配/回收功能

### 系统调用的过程
1. 应用程序将系统调用的参数放入CPU寄存器中(传参)
2. 应用程序执行陷入指令(trap 指令)
3. CPU引发内中断，运行系统调用入口程序，检查寄存器参数，确定系统调用的类型
4. CPU运行与系统调用类型匹配的内核程序
5. 处理完成后返回用户态


## OS的体系结构

内核是OS最基本最核心最底层的部分，实现内核功能的程序称为内核程序。[操作系统的体系结构：大内核VS微内核](#操作系统的体系结构：大内核VS微内核)

![[Pasted image 20230427171256.png]]
- 微内核的缺点是需要频繁变换CPU状态，降低系统性能
典型大内核: Linux, Unix；
典型的微内核: Windows NT



