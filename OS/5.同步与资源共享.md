
# 5.1进程同步与互斥

==**什么是同步**==
- [异步性](1.操作系统的概念#OS的特征)：并发执行的进程以**各自独立**不可预知的速度前进
- 同步性：共同完成某项任务的多个进程，因需要在某些位置上**协调工作次序**而产生的制约关系。
> 例子
> 1. 如进程间通信的[管道通信](2.进程#管道通信)中，读写两个进程是并发的。进程A对某一管道文件写入，而进程B读取该管道文件。如果处于异步的状态，则A还没写完的时候进程发生切换，B将读取不完整的文件。
> 2. 我们的预期是写进程发生在读进程之前！

**进程同步要求并发执行的进程以预期的顺序进行**，OS则需要建立同步机制来满足该条件

==**什么是进程互斥**==
- [共享](1.操作系统的概念#OS的特征)：资源共享，指系统中的资源可以提供给多个并发执行的进程同时使用
- **临界资源：** <u>一个时间段内只允许一个进程访问的资源</u>。如一些物理设备，一些系统变量和数据，缓冲区等资源。
- **进程互斥：** 两个或两个以上的进程，不能同时进入关于同一组共享变量的临界区域，否则可能发生与时间有关的错误，这种现象被称作进程互斥。也就是说，一个进程正在访问临界资源，另一个要访问该资源的进程必须等待。
- **为什么需要进程互斥？** 由于程序并发执行，当某个使用临界资源的进程因时间片用完下处理机后，新的被调度的进程若同样访问临界资源，这会导致临界资源内容出现混乱。
> 如两个进程需要访问打印机资源
> 如果不使用进程互斥，可能会导致两个进程打印的东西混到一起了



# 5.2进程互斥的软件实现

==**互斥访问的实现逻辑**==
- **临界资源的访问标志：** 指示了当前临界资源是否在被某一进程占用
- **互斥访问：** 对临界资源的互斥访问有以下逻辑顺序
  1. 进入区/Entry Section：根据访问标志检查是否可以进入临界区，若可以访问，则应首先设置该访问标志以阻止其他进程访问该临界资源。
  2. 临界区/Critical Section：真正访问临界资源的相关逻辑
  3. 退出区/Exit Section：完成访问，解除访问标志
  4. 剩余区/Remainder Section：其他处理
> 例子：上厕所
> 1. 检查厕所门上是不是写着空闲，如果是，则进去并把门锁好，让门上标志就会变成有人
> 2. 上厕所
> 3. 开门，此时厕所门标志又会写着空闲
> 4. 洗手台洗手

==**互斥访问的原则**==
- 空闲让进：临界区空闲时，应令一个请求进入的进程立即进入临界区
- 忙则等待：临界区忙时，其他试图进入的进程必须等待
- 让权等待：当当前进程**不能进入临界区时应立即释放处理机**，防止进程忙等待
- 有限等待：需要访问临界区的进程应被**保证在有限时间内可以进入临界区**(不产生饥饿)

## 5.2.1|单标志法

- **标志：** 单个全局变量`turn`，**保存可以访问临界资源的PID**
- **判断：** 当前标志与自身PID一致则可以访问
- **上锁：** 不需要上锁
- **让渡：** 在退出区修改标志为另一个进程的PID
- **思想**：前序进程访问完临界区后，会把临界资源访问权限赋予到需要访问的下一个进程。**换而言之，每个进程进入临界区的权限只能被另一个进程赋予。**

- **实现：**
  0. **一个全局变量`turn`，保存当前允许访问该临界资源的进程PID**
  1. 进程检查标志`turn`，若与自身PID一致，则进入临界区，否则继续循环检查标志
  2. 访问结束后的进程在退出区修改全局变量`turn`为下一个需要访问的PID
- **问题**
  1. **当全局变量指示的进程不需要访问临界区。该进程不访问临界资源，相应也不会修改该全局变量至下一个需要访问进程的PID。导致该资源死锁，违反空闲让进和有限等待原则

## 5.2.2|双标志先检查法

- **标志：** 全局布尔型数组`Flag`，**保存各进程对临界资源的主张**
- **判断：** 其他进程不主张占用临界资源(标志数组`Flag`全为`False`)
- **上锁：** 设置标志数组`Flag`中自身主张为`True`
- **让渡：** 设置标志数组`Flag`中自身主张为`False`
- **思想：** 当自己需要临界资源而其他进程不主张该资源时，则进入临界区

- **实现：**
  0. 全局布尔型数组`Flag`，初始值全为`False`
  1. 进程检查标志，若数组`Flag`全为`False`，则进入临界区，否则继续循环检查标志数组`Flag`
  2. 修改`Flag`自身主张为`True`，并进入临界区
  3. 修改`Flag`自身主张为`False`，完成访问

- **问题：**
  - 当在步骤1和2之间产生了进程切换：
     1. A进程检查了所有进程的主张，发现自己可以使用临界资源，并停止了对标志数组的循环检查。
     2. A进程还没声明自己对资源的主张时，发生了进程切换
     3. B进程检查了所有进程的主张，发现自己可以使用临界资源，并停止了对标志数组的循环检查。
     - **结果：在各自的主张时间片内，A，B均认为当前资源无人主张。这违反了忙则等待**
 - Why?：在进入区做了两件事，首先判断，然后再主张。然而在进入去中可能产生进程切换，导致判断和主张没有一气呵成。


## 5.2.3|双标志后检查法

- **标志：** 全局布尔型数组`Flag`，**保存各进程对临界资源的主张**
- **上锁：** 设置标志数组`Flag`中自身主张为`True`
- **判断：** 其他进程不主张占用临界资源(标志数组`Flag`全为`False`
- **让渡：** 设置标志数组`Flag`中自身主张为`False`
- **思想：** 先主张占有资源，再检查其他资源是否主张。不主张则进入临界区。

- **实现：**
  0. 全局布尔型数组`Flag`，初始值全为`False`
  1. 进程修改`Flag`自身主张为`True`
  2. 进程检查标志`Flag`，若除自己外数组全为`False`，则进入临界区，否则继续循环检查标志数组`Flag`
  3. 进入临界区
  4. 修改`Flag`自身主张为`False`，完成访问
- **和双标志先检查法的区别是：**
  - 先检查法是先检查后主张
  - 后检查法是先主张后检查


- **问题：**
  - 当在步骤1和2之间产生了进程切换：
     1. A进程先声明了自己对资源的主张，还未检查其他进程的主张时发生了进程切换
     2. B进程先声明了自己对资源的主张，检查其他进程发现A也在主张，B无法进入临界区
     3. A进程检查了其他进程，发现B也在主张临界区，A无法进入临界区
     - **结果：在各自的判断时间片内，A，B均认为当前资源有人主张，都无法进入临界区。导致资源死锁，违反空闲让进和有限等待原则**
 - Why?：在进入区做了两件事，进程切换回导致主张和判断没有一气呵成。

## 5.2.4|Peterson算法

Peterson算法结合了单标志法和双标志法

- **标志：**
  1. 全局变量`turn`，表示优先使用的进程PID
  2. 全局标志数组`Flag`，表示各进程对临界区资源的主张
- **上锁：** 设置标志数组`Flag`中自身主张为`True`
- **谦让：** 设置全局变量`turn`为其他进程的PID
- **判断：** 当其他进程不主张资源或优先使用临界区资源的PID是自己时，进入临界区
- **让渡：** 设置标志数组`Flag`中自身主张为`False`

- **实现**
  0. 全局布尔型数组，初始值全为`False`，全局变量优先使用资源的PID初始值为某一PID
  1. 进程**主张使用资源**，设置标志数组`Flag`对应位置为`True`
  2. 进程**谦让资源**，设置`turn`优先使用PID的值为其他进程的PID
  3. 进程判断，以下任意情况发生则进入临界区，否则循环判断
     - 当其他进程均不主张资源
     - 优先使用的PID为自己的PID
  4. 进入临界区
  5. 让渡，修改标志数组为`False`

- 总结：谁最后谦让，谁就最后使用资源，可以实现空闲让进、忙则等待、优先等待。但未遵循让权等待
- 问题： 
  1. 最后一个谦让的进程谦让的PID必须是将要使用资源的PID，否则导致死锁


# 5.3进程互斥的硬件实现

## 5.3.1|中断屏蔽方法

- **思想：** 直接禁止进程切换来进行互斥访问
- **实现：** 
  1. 进程在**进入区进行关中断**
  2. 进程进入临界区
  3. 进程在**退出区进行开中断**
- **优点：**简单、高效
- **缺点：**
  1. 不适用多处理机 (因为关中断只能关一个CPU)，如果其他进程在其他CPU上访问临界区就会不安全
  2. 不适用于用户态进程 (因为只有内核进程才能进行开关中断指令，而且不能进行系统调用来实现开关中断)

## 5.3.2|TestAndSet指令

- `TestAndSet / TS`指令，也称`TestAndSetLock / TSL`指令
- **TSL指令用硬件实现，且具有原子性**
- **思想：上锁和判断指令一气呵成**


- 共享变量`lock`指示该资源锁的状态
  - `True` ：资源上锁
  - `False` ：资源未加锁
- TSL指令逻辑：返回当前`lock`的值并设置`lock`的值未`True`
```C
bool *lock;       // lock 为指向临界资源上锁状态的指针
bool TestAndSetLock(bool *lock)
{
	bool old;
	old = *lock;   // old储存原来锁的状态
	*lock = true;  // 无论之前是否上锁，现在都把锁给上了
	return old;    // 返回之前锁的状态
}
```

- 进程访问机制
```C
while(TestAndSetLock(lock));  // 上锁并检查锁的状态
// Critical Section
*lock = false;
// Remainder Section
```

- **原理：**
  - **不准入：** 如果当前`lock`为`true`，即资源上锁。则TSL会返回`True`值使得进程在访问时落入循环中，同时TSL也会保持锁状态为上锁。当进程切换时其他进程仍会发现资源上锁。
  - **准入：** 如果当前`lock`为`false`，即资源解锁。则TSL会返回`False`使得进程跳出循环，同时TSL已经为资源上锁。即使发生了进程切换，其他进程仍会发现资源已经上锁。
  - **解锁：** 占用资源的进程在退出区设置`lock`为`false`

- 优点：实现简单、无逻辑漏洞、适用于多处理机
- 缺点：不满足让权等待

## 5.3.3|swap指令

- 原子指令 `swap`指令，或`Exchange / XCHG`指令
- 指令可以互换两个指针指向对象的值，且一气呵成
- **思想：上锁和判断一气呵成**，实际上和TSL是一样的原理

```C
// 交换a, b两个指针指向的内容
void swap(bool *a, bool *b)
{
	bool temp = *a;
	*a = *b;
	*b = temp;
}
```

```C
bool old = true;
while (old == true)
{
  swap(&lock, &old);
}
// Critical Section
lock = false;
```

- 原理：
  - **不准入：** 当`lock`为`true`时，进程无论swap多少次，`old`都为`true`，无法跳出循环
  - **准入：** 当`lock`为`false`时，进程swap一次即使得`lock`为`true`， `old` 为`false`。进程跳出循环，并进入准入区
  - **解锁：** 在退出区设置`lock`为`false`
  
  
- 优点：实现简单、无逻辑漏洞、适用于多处理机
- 缺点：不满足让权等待

# 5.4锁

**==自旋锁(Spin Lock)==** ：需要循环检测（自旋）锁状态导致忙等的锁，包括了TSL指令，swap指令、单标志法，都会导致忙等，违反让权等待

- 自旋锁优点：等待期间不切换上下文，在多处理器系统中**如果上锁时间短则代价低**
- 缺点：在单处理机中出现忙等

==**互斥锁 / Mutex Lock**==
- 实现互斥的方法
- 字段：
  1. `bool lock`：指示当前锁状态，`true`为上锁，`false` 为解锁
- 方法(均为原子操作)：
  1. `void acquire()`：为`true`时循环地检查`lock`上锁状态，为`false`时为其上锁并跳出循环
  2. `void release()`：令`lock`为`false`
```cpp
class MutexLock
{
private:
	bool lock = false;
public:
	void acquire()
	{
		while(lock);
		lock = true;
	}
	void release()
	{
		lock  = false;
	}
}
```
- 缺点：忙等


# 5.5信号量机制

信号量机制 ：
1. 实现进入区检查+上锁一气呵成
2. 实现让权等待
3. 实现同步和互斥

信号量
- 可以是一个整型变量/更为复杂的变量
- 表示系统某种资源的数量

信号量的PV原语
- P(wait) / V (signal) 原语对信号量进行操作


## 5.5.1|整型信号量

- 整型信号量机制，用单个整型变量表达可以剩余的
- 在进入去仍会发生忙等
```cpp
// 信号量
int S = 1;


// 相当于进入区
void wait(int &S)
{
	while (S <= 0);
	S -= 1;
}

// 相当于退出区
void signal(int &S)
{
	S += 1;
}
```


## 5.5.2|记录型信号量

- `value` 为正时，则为当前还能允许多少个进程使用资源
- `value` 为零时，则说明无可用资源，又无等待进程
- `value` 为负时，其绝对值则为阻塞队列中有多少个进程
- ==在这种信号量机制中，要注意的一个地方是`wait()` 和`siganl()`两个原语在每个进程每次申请中只会调用一次！==而之前的互斥机制中类`wait()`的原语在进入区可能调用多次以检查是否有可用资源。
- 我们一定要注意，因为`value`可以为负，所以它的含义和”当前可用资源数“是不同的，这解释了为什么在`signal`中`value <= 0`时仍可以分配资源给阻塞队列中的进程
- 如果我们想知道当前可用的资源到底有多少，则应该新设立一个变量`left`：
  1. `left`初始值为OS提供资源数量，且非负
  2. `wait()`中，只有成功进入临界区的进程才能`left -= 1`
  3. `siganl()`中，退出区归还资源后才能`left += 1`，若此时又唤醒了一个进程，则应`left -= 1`

```cpp
class semaphore
{
private:
	// 资源数量
	int value;
	// 等待队列
	std::queue<process> L;
public:
	// 进入区调用
	void wait(process P)
	{
		// 申请占用一个资源
		value -= 1;
		// 当占用后资源剩余量小于0, 说明其实没有资源可用，应阻塞
		if (value < 0)
		{
			block P;     // 阻塞申请进程
			L.append(P); // 将申请进程加入等待队列中
		}
	}

	// 退出区调用
	void signal()
	{
		// 结束占用, 归还资源
		value += 1;
		// 如果有资源正在等待使用，则可以唤醒它(因为此时已经归还了一次资源了)
		if (resources <= 0)
		{
			process P = L.popfront();
			wake P;
		}
	}

}
```

对于申请进入临界区的进程，在尝试申请一个资源（`resources -= 1`）后
- `resources` 为正：说明还有资源可用
- `resources` 为零：说明自己刚好用完了资源
- `resources` 为负：说明资源本身就已经用完，只能进入阻塞队列等待其他进程释放
- 因此，申请后 `resources < 0 ` 时应阻塞

对于在退出区的进程，在归还资源（`resources += 1`）后
- `resources` 为正：说明归还资源之前仍然有余量，而且队列中没有进程在等待
- `resources` 为零：说明目前恰好有一个进程在等待资源（归还前`resources = -1`）
- `resources` 为负：说明目前有数个进程正在等待资源
- 因此，归还后 `resources <= 0 `时应唤醒一个进程

- 显然记录型信号量能实现让权等待


## 5.5.3|信号量机制与互斥

**==实现互斥：==**
1. 划定临界区
2. 设置互斥信号量`mutex`为1
3. 在进入区使用P操作申请资源
4. 在退出区使用V操作释放资源

## 5.5.4|信号量机制与同步和前驱

[进程同步](#5.1进程同步与互斥): 有时需要某些进程一前一后地执行，但由于并发过程的异步性，这一点有时难以保证

**==前驱/多级同步==**
- 使用记录型信号量机制，令信号量初始值为0，先行进程能对其V操作，后行进程能对其P操作。==**其含义是，刚开始没有任何资源，先行代码段能释放一个”资源“，后行代码段需要一个”资源“。于是当后行代码段执行时，则需等待先行代码段的执行完并释放资源才能继续运行。**==
- 实现A进程代码段A2先于 进程B代码段B3执行的方法：
  1. 设定`semaphore S = 0`
  2. 在先行进程A2后加入`V(S)`
  3. 在后行进程B3前加入`P(S)`
  - 也就是对S来说，先V后P


# 5.6同步与互斥的现实问题

## 5.6.1|生产者-消费者问题

一个互斥和同步的中和问题

- 一个缓冲区，容量为`V`
- 互斥问题：缓冲区为临界资源，一次只能由一个生产者/消费者使用
- **同步问题**：
  1. 仅货架非满时，生产者能生产货物
  2. 仅货架非空时，消费者能消费货物

**==解决逻辑==**
- **生产者只需关注是否有空闲缓冲区**
- **消费者只需关注缓冲区是否有内容**

信号量实现：
1. 为实现缓冲区访问互斥，应设置互斥`semaphore buffer = 1;`
2. 为实现有空闲才生产，设置同步信号量`semaphore empty = V;`
3. 为实现有货物才消费，设置同步信号量`semaphore data = 0;`

运行实现：
- 生产者进程：
  1. 生产货物
  2. 检查是否有空闲缓冲区：`P(empty)`
  3. 检查是否能访问缓冲区：`P(buffer)`
  4. 交付货物（写入缓冲区）
  5. 释放缓冲区`V(buffer)`
  6. 增加货物资源`V(data)`
- 消费者进程：
  1. 检查是否有货物：`P(data)`
  2. 检查缓冲区访问可用性：`P(buffer)`
  3. 从缓冲区读走货物
  4. 释放缓冲区，增加空闲缓冲区资源`V(buffer)`，
  5. 增加空闲缓冲区`V(empty)`
  6. 使用货物

- **==为什么要先检查空闲/有货 再检查缓冲区访问权限 ？==**
  因为如果相反，可能存在缓冲区可访问，但无法向其读写资源（无货/无空位）的情况。
  这种情况会阻塞当前进程，直到无货/无空位的情况解决。**然而又因为缓冲区被当前进程占用，无货/无空位情况无法改变**，这将造成缓冲区死锁，即进程互相等待。
  *==**因此，实现互斥的P操作应在实现同步的P操作以后**==*
- 释放缓冲区访问权限和释放空闲/有货可以相反吗？
  可以，因为不会造成任何进程阻塞，这就不会导致死锁
- 为什么生产/使用货物要在临界区以外
  因为临界区越长，其他进程等待临界区的时间就会越长，不利于更好地并发。**我们应该令临界区代码尽可能短**

## 5.6.2|多生产者-多消费者问题

一个更复杂的生产者-消费者问题，**多指的是多类别货物**

- 有限的缓冲区资源，容量为`V`
- 互斥问题：只允许一个进程访问缓冲区
- 同步问题：
  1. 仅缓冲区非满时，生产某一类型货物的进程才能向其中添加货物
  2. 仅缓冲区内有某一类型货物时，对应类型消费者才能从其取出货物

也就是说，有多种货物，产生了不同类型货物的生产者和消费者


**==解决逻辑==**
- **生产者只需关注缓冲区有没有空闲位置，有就能放**
- **消费者只需关注缓冲区有没有想要的类型，有就能取，而无需关注缓冲区的内容大小**

运行实现：
1. 缓冲区访问互斥变量：`semaphore buffer(1);`
2. 缓冲区空闲大小：`semaphore empty(V);`
3. 缓冲区内某一类型货物数量：`semaphore type(0);`

- `type`的生产者进程：
  1. 生产一个货物`type`
  2. **检查缓冲区空闲**，`empty.P()`
  3. 检查缓冲区读写权限，`buffer.p()`
  4. 将货物写入缓冲区
  5. 释放缓冲区权限，`buffer.V()`
  6. 增加一个对应类型货物数量，`type.V()`
- `type`的消费者进程
  1. **检查存在`type`货物**，`type.P()`
  2. 检查缓冲区读写权限，`buffer.P()`
  3. 将一个`type`类型货物取出
  4. 释放缓冲区权限,`buffer.V()`
  5. 增加一个缓冲区空闲，`empty.V()`
  6. 使用货物`type`

## 5.6.3|吸烟者问题

- 有三种资源：rA, rB, rC
- 有一个生产者进程，能够产出rA, rB, rC三种资源
- 有一个缓冲区，能存放资源的两种
- 有三个消费者进程，分别需要:
  1. pA：需要rB, rC
  2. pB：需要rA, rC
  3. pC：需要rA, rB
- 需要设计一个方法，使得pA, pB, pC能够轮流进行消费

解决：
- 首先可以将需要资源的组合进行抽象：
	pA - rA
	pB - rB
	pC - rC
- 我们可以假设缓冲区大小为1，即每次能储存一个组合的资源
- 生产者在自己的while循环中就能实现轮流生产抽象资源组合


- 设置三个同步信号量：
  1. `rA(0)` 代表资源rA的生产情况
  2. `rB(0)` 代表资源rB的生产情况
  3. `rC(0)` 代表资源rC的生产情况
- 设置一个互斥信号量控制缓冲区访问
  1. `buffer(1)`

- 生产者：
  - 循环执行(X 自增)：
  1. `buffer.P()`：等待缓冲区可以写入
  2. 将下一个资源`rX` 放入缓冲区
  3. `buffer.V()`：释放缓冲区
  4. `rX.V()`：释放资源rX

- 消费者X：
  1. `rX.P()`：等待rX资源
  2. `buffer.P()`：等待缓冲区可以读取
  3. 将`rX`资源读走
  4. `buffer.V()`：释放缓冲区


```cpp
semaphore ra(0);
semaphore rb(0);
semaphore rc(0);
semaphore buffer(1);

void provider()
{
	while(True)
	{
		buffer.P();
		rA() -> buffer;
		buffer.V();    ra.V();
		
		buffer.P();
		rB() -> buffer;
		buffer.V();    rb.V();
		
		buffer.P();
		rC() -> buffer;
		buffer.V();    rc.V();
	}
}

void pA()
{
	ra.P();
	buffer.P();
	buffer -> rA;
	buffer.V();
}
```


## 5.6.4|读者-写者问题

- 一个共享的文件
- 多个进程能对其写
- 多个进程能对其读
- 在无写入情况时，允许多个读进程访问文件
- 写入时，只允许一个写进程访问文件

**==逻辑==**
1. 无论是哪种进程，都只需要关注有没有其他进程在写入。如果没有就可以执行。
2. 读进程工作时，写进程不能写入

==**解决方案1：读友好**==
- 逻辑：创建一个读进程数量计数器
- 设置一个互斥信号量`semaphore rw(1)`
- 设置一个整型变量为访问文件的读进程数量`int count = 0`
- 设置一个互斥信号量保证对`count` 访问是互斥的`semaphore cw(1)`

- 写进程：
  1. `rw.P()` 申请写权限
  2. 写入
  3. `rw.V()` 释放文件

- 读进程：
  1. `cw.P()`：申请对`count`进行访问
  - `if(count == 0)`：当自己是首个读进程时
    1. `rw.P()` 上锁
  2. `count ++` 令读进程计数+1
  3. `cw.V()` 释放`count` 访问权限
  4. 读文件
  5. `cw.P()`：申请对`count`进行访问
  6. `count --`：表示自己已经读完
  - `if(count == 0)`：当自己是首个读进程时
    1. `rw.V()` 释放读权限
  7. `cw.V()` ：释放`count`

- 问题：
  1. 只要读进程源源不断地出现，则可能出现`rw`长期被锁，导致写进程无法操作

==**解决方案2：写友好**==
- 逻辑：当有进程申请写时，则**禁止新的读进程**尝试获取文件
- 设置一个互斥信号量`semaphore rw(1)`
- 设置一个整型变量为访问文件的读进程数量`int count = 0`
- 设置一个互斥信号量保证对`count` 访问是互斥的`semaphore cw(1)`
- 设置一个阻塞创建新的读进程的互斥信号量`semaphore w(1)`

- 写进程：
  1. `w.P()` 申请阻塞读进程
  2. `rw.P()` 申请写权限
  3. 写入
  4. `rw.V()` 释放文件
  5. `w.V()` 释放读进程权限

- 读进程：
  1. `w.P()`：检查读进程是否阻塞
  2. `cw.P()`：申请对`count`进行访问
  - `if(count == 0)`：当自己是首个读进程时
    1. `rw.P()` 上锁
  3. `count ++` 令读进程计数+1
  4. `cw.V()` 释放`count` 访问权限
  5. `w.V()` 释放读进程权限
  6. 读文件
  7. `cw.P()`：申请对`count`进行访问
  8. `count --`：表示自己已经读完
  - `if(count == 0)`：当自己是首个读进程时
    1. `rw.V()` 释放读权限
  9. `cw.V()` ：释放`count`

- 问题：
  1. 当有源源不断的写进程出现时，读进程会饥饿


## 5.6.5|哲学家进餐问题

![[Pasted image 20230608195755.png]]
- 每个哲学家需要两个互斥资源
- 每个互斥资源可能会被两个哲学家所需要

信号量设置：
- `semaphore chopstick[5];`
- `i`位哲学家左边的筷子是`i`，右边的是`(i+1)%5`

解决方案1：**导致死锁**
- 每个哲学家吃饭时都对自己左右两边的筷子上锁
- 但是会导致死锁，因为如果大家都拿起左边的筷子，那大家都拿不到自己右边的筷子

解决方案2：**只允许1个哲学家吃饭**
- 设置互斥信号量来保证只有一个哲学家吃饭
- 互斥信号量`semphore dinner(1)`
- 进餐方式：
  1. `dinner.P()`：请求进餐
  2. 进餐
  3. `dinner.V()`：释放进餐名额

解决方案3：**只允许4个哲学家同时进餐**
- 即可保证至少有一个哲学家能拿到两个筷子
- 同步信号量`semaphore dinner(4)`
- 进餐方式
  1. `dinner.P()` 要求进餐
  2. `chopstick[i].P()` 要求左边的筷子
  3. `chopstick[(i+1)%5].P()` 要求右边的筷子
  4. 进餐
  5. `chopstick[(i+1)%5].V()` 释放右边的筷子
  6. `chopstick[i].V()` 释放左边的筷子
  7. `dinner.V()` 吃完了
  
解决方案4：**奇数拿左，偶数拿右**
- 奇数哲学家先拿左边的筷子，再拿右边的筷子
- 偶数哲学家先拿右边的筷子，再拿左边的筷子
- 可以保证相邻两个哲学家：
  1. 要不是第一次拿筷子时尝试拿同一根筷子
  2. 要不是第二次拿筷子时尝试拿同一根筷子
  - 就不会导致死锁
- 进餐方式：根据奇数或偶数设置


# 5.7管程

## 5.7.1|概念

为什么要有管程？
- 使用PV操作，代码逻辑复杂，还容易出错

定义：

组成：
1. 管程的名字
2. 管程的内部数据，这包含了临界资源
3. 提供对内部数据结构进行操作的方法/函数
4. 初始化语句

特征：
1. 管程内部数据对外不可见(相当于`private`)
2. 管程中的**临界资源只能通过其方法进行操作** 
3. 一次只能有一个进程使用管程的某个方法

总结：使用类似于一个**类实例来对临界资源**进行访问，访问临界资源的进程不用关的实现
```cpp
class ProducerConsumer
{
private:
	// 互斥变量
	semaphore full;
	semaphore empty;
	Buffer buffer;

public:
	/// 初始化函数，接受资源个数
	ProducerConsumer(int resources, const Buffer & Abuffer)
	{
		full(0);
		empty(resources);
		buffer = Abuffer;
	}

	void insert(Item item)
	{
		empty.P();
		buffer.insert(item);
		full.V();
	}
	
	Item pop()
	{
		full.P();
		Item item = buffer.pop();
		empty.V();
		return item;
	}
}

void Producer()
{
	while(1)
	{
		Item item();
		ProducerConsumer.insert(item);
	}
}

void Consumer()
{
	while(1)
	{
		Item item = ProducerConsumer.pop();
	}
}

```


# 5.8死锁

## 5.8.1|死锁的概念
**==死锁的概念==**
- **所有并发进程均占有一个以上被其他进程等待的资源**，造成各进程都在阻塞
- 或：所有并发进程均在循环等待其他进程占有的资源，造成各进程都在阻塞
- 产生原因：资源分配策略

==**饥饿的概念**==
- **某一并发进程**长时间得不到想要的资源，导致进程无法向前推进
- 产生原因：资源分配策略

==**死循环的概念**==
- 某一进程在执行过程中**无法跳出某个循环**，使得后续代码无法执行 
- 产生原因：程序设计

## 5.8.2|死锁的必要条件

**==死锁发生的条件==**
只有以下所有条件**都成立**时才可能发生死锁
1. **资源互斥**：必须是对互斥使用的临界资源才会导致死锁
2. **无法剥夺**：进程获取互斥资源后只能主动释放，不能被其他进程强行夺走
3. **持有和请求**：进程在持有一个互斥资源的条件下仍请求一个新的互斥资源
4. **循环等待**：各进程存在循环等待资源的等待链，即链中每一个进程均持有(至少)一个被其他进程等待的资源
   循环等待不必然导致死锁，如果某一进程等待的资源有两份，一份被其他进程占有，一份空闲，这种情况就不导致死锁。但如果每一种被等待的资源均只有1份，那就充分必要地导致死锁。

**==死锁发生的时机==**
1. **对不可剥夺的系统资源进行竞争**：显然。
2. **进程的推进非法**：
   1. 如尝试在互斥等待后进行同步等待
   2. 不一致的请求顺序：
      如A, B均需要1, 2两个资源，但A请求顺序是1-2，B请求顺序是2-1


## 5.8.3|死锁的预防

- 目标：破坏死锁发生的4个条件
1. **资源互斥**
2. **无法剥夺**
3. **持有和请求**
4. **循环等待**

对应做法：
1. ==**允许共享资源**==：将只能互斥使用的资源改为允许共享使用，如SPOOLing
> 例子. SPOOLing技术/假脱机技术
> **相当于设定中间人，中间人完成对互斥资源的操作**。
> 当一个进程请求互斥资源时
> 1. 将指令、数据会被传给中间进程。
> 2. **进程认为已经完成临界区操作**，可以退出
> 而中间进程会依次执行收到的指令，相当于单独完成互斥资源的管理
- 有很多情况互斥是没有办法避免的，所以使用SPOOLing不能必然预防死锁

2. ==**允许剥夺**==：
   方案：
   - 当某个进程**请求新的资源得不到满足时，应释放保持的所有资源**。等待合适时重新申请。(可能导致饥饿)
   - 当某个高优先级进程需要一个已经被占用的资源时，**OS可剥夺该资源权限赋予高优先级进程** (实现复杂，且可能影响已经执行的工作，一般只适用于已于保存和恢复的资源如CPU)

3. **==静态请求==**：**即一次请求所需的全部资源**。当无法满足时不投入运行，请求成功后就不再请求资源。
   - 缺点：资源利用率低(并发度低)，也可能导致请求多个频繁被使用的资源的进程饥饿

4. **==顺序资源分配==**：对资源进行编号，每个进程必须按照编号递增的顺序请求资源。
   - 拥有小编号资源的进程可能等待拥有大编号资源的进程释放资源
   - 但是拥有大编号资源的进程不可能等待拥有小编好资源的进程
   - 由此可以打破循环等待的情况
   - 问题：
     1. 不利于扩容(增加新类型资源)
     2. 使用过程中不同进程对不同资源申请顺序在逻辑上可能不一样(如一个进程要先使用打印机再使用扫描仪，而另一个则反过来。但是这种解决方案中只能一个顺序)
     3. 用户编程麻烦

## 5.8.4|死锁避免

**==概念==**
- **安全序列**：系统若按照这种序列分配资源，则每个进程都能顺利完成。只要能找到一个安全序列，则系统就是安全状态。
- **安全状态**：存在至少一个安全序列，则可以使得系统不发生死锁

**==安全序列与死锁的关系==**
安全序列->一定不死锁
不安全序列->不一定发生死锁
发生死锁->一定由不安全序列导致

**==问题的定义==**
1. 有n个进程，$P_1, P_2...P_n$
2. 有m类资源，当前系统里每种资源分别有$R_1,...R_m$个可用资源，构成当前资源向量$R$
3. 进程`i`在在运行过程中最多需要`j`类资源$M_{i, j}$个，所有进程构成最大需求$Max$矩阵$M$
4. 进程申请资源不一定一次全部申请完，而是可能分批次申请，但不应超过$M_i$
5. 当前状态下进程`i` 被分配了$A_{i, j}$ 个`j`类资源，所有进程构成了已分配$Allocated$矩阵$A$
6. 当一个进程的所有资源要求被满足时($A_i = M_i$)，进程可以运行并在结束后归还所有资源。如此，即$R += A_i$
7. 进程可以多次发出资源请求，每次的资源数量都不一样。但其持有的资源不应超过$Max$
8. 需要寻找一种进程资源分配顺序，每次满足一个进程的资源需求，并保证下一次能分配一个进程。

**==银行家算法==**：
- 逻辑：
  如果我给A分配了其申请的资源
  是否会导致接下来，对所有还没结束的进程
  其最大可能的需求(`Max[i] - A[i] > R`)都无法被满足
- 算法：进程`i`请求`Need`向量资源时
  1. `A[i] + Need <= Max[i]`：即进程请求资源后是否超过了其声明的最大资源要求
  2. `Need < R`：即请求的资源是否超出系统当前剩余的资源
  3. `Max[all] - A[all] all> R - Need ` 分配以后，是否可能存在无法满足任意一个进程的最大资源请求
     对于可以的进程，可以把它加入安全队列，并把其持有的资源回收
     不断重复上述过程，看看是否能把所有进程都加入安全队列

  
## 5.8.5|死锁的检测


1. 特殊数据结构保存资源的请求和分配信息
2. 提供一种算法用于检测系统是否进入死锁


![[Pasted image 20230620201116.png]]
- 分别有蓝色和绿色两种框框，绿框是资源，蓝框是进程
- 分别有两种线，绿线表示资源已分配给进程，南线表示进程在请求资源

- 检测方法：观察是否能消除所有的线：
    - 依次消除与不阻塞进程相连的便，直到无边可消 

- 解除死锁：当尽最大可能消除所有线后，发现还有无法消除的线时
  1. 资源剥夺法：挂起某些处于阻塞状态的进程，并抢占其资源分配给其他死锁进程
  2. 撤销/终止进程：强制撤销部分或所有死锁进程
  3. 回退：让死锁进程回退到可以避免死锁的地步。则要求系统记录进程的历史信息，并记录还原点。
  - 优先对哪个进程动手？
    1. 低优先级
    2. 已运行时间短
    3. 剩余运行时间长
    4. 持有资源多
    5. 批处理进程