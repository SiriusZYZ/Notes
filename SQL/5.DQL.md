Data Query Language


查询关键字：`SELECT`
单表查询
```mysql
SELECT
	{字段列表} -- 要查询哪些对象
FROM
	{表名列表} -- 要查询哪些列表
WHERE
	{条件列表} -- 被查询的数据行应满足什么条件
GROUP BY
	{分组字段列表} -- 查询的结果按照什么字段进行分组
HAVING
	{分组后条件列表} -- 分组后的查询结果应满足什么条件
ORDER BY
	{排序字段列表} -- 
LIMIT
	{分页参数}
;
```

由此，我们产生多种查询类别

# 5.1基本语法

## 5.1.1|查询多个字段
```mysql
SELECT 字段1, 字段2, ... FROM 表名;
SELECT * FROM 表名;
```

> 例子1. 查询若干个字段
```mysql
mysql> select name, workno, age from emp;
+------+--------+------+
| name | workno | age  |
+------+--------+------+
| a    | 1      |   20 |
| b    | 2      |   18 |
| c    | 3      |   38 |
| d    | 4      |   18 |
| e    | 5      |   20 |
| f    | 6      |   28 |
| g    | 7      |   48 |
| hh   | 8      |   38 |
| i    | 9      |   45 |
| j    | 10     |   18 |
+------+--------+------+
10 rows in set (0.00 sec)
```
查询结果是
- 具有的字段是`name, workno, age`
- emp表中的所有数据(因为没有条件)

> 例子2. 使用`*`查询所有字段
```mysql
mysql> select * from emp;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|    9 | 9      | i    | f      |   45 | 123452389012345678 | Beijing     | 2010-04-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
10 rows in set (0.00 sec)

```

## 5.1.2|设置别名以增加可读性
```mysql
SELECT 字段1 [AS 别名1], 字段2 [AS 别名2], ... FROM 表名;
```

> 例子3. 使用别名来增加可读性
```mysql
mysql> select workaddress as "工作地址" from emp;
+----------+
| 工作地址 |
+----------+
| Beijing  |
| Beijing  |
| Shanghai |
| Beijing  |
| Shanghai |
| Beijing  |
| Beijing  |
| Tianjin  |
| Beijing  |
| Beijing  |
+----------+
10 rows in set (0.00 sec)
```
查询结果：
- 表中所有数据行的`address`值
- 返回结果中`address`被别名`工作地址` 代替

## 5.1.3|去除重复记录
```mysql
SELECT DISTINCT 字段1, 字段2, .. FROM 表名;
```
Distinct**指的是结果中不会出现完全相同的行**，而非某一字段不会出现重复的值。详见：

> 例子4.去除查询结果中重复的值
```mysql
mysql> select distinct workaddress as "工作地址" from emp;
+----------+
| 工作地址 |
+----------+
| Beijing  |
| Shanghai |
| Tianjin  |
+----------+
3 rows in set (0.00 sec)

mysql> select distinct gender, workaddress as "工作地址" from emp;
+--------+----------+
| gender | 工作地址 |
+--------+----------+
| f      | Beijing  |
| m      | Beijing  |
| m      | Shanghai |
| f      | Shanghai |
| f      | Tianjin  |
+--------+----------+
5 rows in set (0.00 sec)
```
查询结果1：仅查询工作地址
- 因此结果中工作地址不会有重复

查询结果2：查询性别和工作地址
- **同一个工作地址可能会有不同性别的员工，而同一性别的员工也可能在不同的工作地址中工作**
- 因此查询结果中会显示与仅查询工作地址有区别的结果


# 5.2条件查询

```mysql
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```
- where 后面字段是不加引号的

| 比较运算符            | 功能                                         |
| --------------------- | -------------------------------------------- |
| `>`                   | 严格大于                                     |
| `>=`                  | 大于等于                                     |
| `<`                   | 严格小于                                     |
| `<=`                  | 小于等于                                     |
| `=`                   | 逻辑等于                                     |
| `!=`                  | 不等于                                       |
| `BETWEEN min AND max` | 在区间`[min, max]` 内(含最大最小值)                         |
| `IN (...)`            | 在`(...)`值列表中                            |
| `LIKE {占位符}`       | 模糊匹配，`_`匹配单个字符，`%`匹配任意个字符 |
| `IS NULL`             | 是`null`值                                   |

| 逻辑运算符 | 功能 |
| ---------- | ---- |
|  `AND` 或 `&&`         | 逻辑且                                       |
| `OR` 或          | 逻辑或                                       |
| `NOT` 或`!`           | 逻辑非                                       |           |      |

- 注意， NOT一般加语句前面，[例子](#5.2.2值NULL与否)：
```mysql
-- Correct NOT 可以放在条件语句前面
select * from emp where not idcard is null;

-- Correct NOT可以放在 IS NULL 中间
mysql> select * from emp where idcard is not null;

-- Wrong NOT 不放在参数和运算符之间
select * from emp where idcard not is null;
```

- 可以使用括号括起条件语句来增加可读性或设定运算优先级，[例子](#5.2.3使用逻辑运算符并列条件)

## 5.2.1根据值的大小

> 例子5. 查询值为...的数据
```mysql

-- 1(1). 查询值恰为....
mysql> select * from emp where age = 18;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
3 rows in set (0.00 sec)

-- 1(2). 查询值为...中任一
mysql> select * from emp where age in (18, 28, 38);
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
6 rows in set (0.00 sec)

-- 2(1). 查询值与...比较
mysql> select * from emp where age <= 25;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)

-- 2(2). 查询值与...比较
mysql> select * from emp where entrydate < "2010-01-01";
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
7 rows in set (0.00 sec)
```
- 日期也可以进行比较操作，后续也可以使用`between ... and ...`来寻找日期范围

> 例子6. 查询值在...之间的数据
```mysql
mysql> select * from emp where entrydate between "2000-01-01" and "2010-01-01";
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
7 rows in set (0.00 sec)
```

## 5.2.2值NULL与否

> 例子7. 查询值为空或非空的数据
```mysql
mysql> select * from emp where idcard is null;
+------+--------+------+--------+------+--------+-------------+------------+
| id   | workno | name | gender | age  | idcard | workaddress | entrydate  |
+------+--------+------+--------+------+--------+-------------+------------+
|   10 | 10     | j    | f      |   18 | NULL   | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------+-------------+------------+
1 row in set (0.00 sec)

mysql> select * from emp where not idcard is null;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|    9 | 9      | i    | f      |   45 | 123452389012345678 | Beijing     | 2010-04-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
9 rows in set (0.00 sec)

mysql> select * from emp where idcard is not null;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|    9 | 9      | i    | f      |   45 | 123452389012345678 | Beijing     | 2010-04-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
9 rows in set (0.00 sec)

mysql> select * from emp where idcard not is null;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'is null' at line 1
```
- 根据结果可以发现，`NOT` 关键字可以放在


## 5.2.3使用逻辑运算符并列条件

> 例子8. 使用逻辑运算符并列条件
```mysql
-- 1. 使用括号括起单个条件
mysql> select * from emp where (gender != "f") and (age between 18 and 50);
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
4 rows in set (0.00 sec)

-- 2. 不适用括号括起单个条件
mysql> select * from emp where gender != "f" and age between 18 and 50;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
4 rows in set (0.00 sec)
```


## 5.2.4占位符

>例子 9.匹配长度为2的值
```mysql
mysql> select * from emp where name like "__";
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
1 row in set (0.00 sec)
```
- 每个`_` 代表了一个字符

> 例子 10.匹配某一位是某个字符的值
```mysql
-- 1. 查询最后一位是X的值
mysql> select * from emp where idcard like "%X";
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
1 row in set (0.00 sec)

-- 2. 查询包含X的值
mysql> select * from emp where idcard like "%X%";
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
1 row in set (0.00 sec)
```
- `%` 代表任意长度的字符



# 5.3聚合函数

聚合函数将==**一列**==数据作为一个整体进行纵向计算：
常见函数：

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum      | 求和          |

需要注意的是所有`NULL` 值是不会进行计算的
基本语法:
```mysql
select Function(Field) from table_name;
```
- 返回的值就是Function的结果，如`max(Field)`返回的结果是该字段的最大值，不包含其他的了
- 返回值实际上可以多个堆叠，即多个Function放在select后面

> 例子11. 使用聚合函数执行
```mysql
-- 1.(1) 统计数据行数
mysql> select count(*) from emp;
+----------+
| count(*) |
+----------+
|       10 |
+----------+
1 row in set (0.03 sec)

-- 1.(2) 统计数据行数的失败例子: 由于某一行的某一字段值为null，所以该行没有被统计
mysql> select count(idcard) from emp;
+---------------+
| count(idcard) |
+---------------+
|             9 |
+---------------+
1 row in set (0.00 sec)

-- 2. 返回多个聚合函数的值
mysql> select count(age), avg(age), max(age), min(age) from emp;
+------------+----------+----------+----------+
| count(age) | avg(age) | max(age) | min(age) |
+------------+----------+----------+----------+
|         10 |  29.1000 |       48 |       18 |
+------------+----------+----------+----------+
1 row in set (0.00 sec)

-- 3. 返回符合某个条件的数据行聚合之和
mysql> select avg(age) from emp where workaddress = "Beijing";
+----------+
| avg(age) |
+----------+
|  27.8571 |
+----------+
1 row in set (0.00 sec)
```

# 5.4分组查询

```mysql
select Fields... From table_name where Conditions... Group by GroupFields Having GroupConditions;
```
条件：
1. where 后条件用于表中数据行的初步筛选
2. group by后条件进行分组
3. having 后的条件进行分组后的数据集筛选

内部执行顺序：
1. 首先，查询语句从conditions 中确定符合条件的数据行
2. 接下来，将1得到的数据行划分成`Group Fields`互不相同的若干数据集合
3. 对每一个2得到的数据集合执行having 后的`GroupConditions`语句，确定满足`GroupConditions`的集合
4. 对3中每个集合进行select后面的查询对象并输出

> 例子12. 分组查询时使用聚合函数
```mysql
-- 1(1). 不在select后的查询对象加入分组的字段，而直接使用group by，无法确定结果来自哪一个分组
mysql> select count(*) from emp group by gender;
+----------+
| count(*) |
+----------+
|        6 |
|        4 |
+----------+
2 rows in set (0.00 sec)

-- 1(2). 应在select后的查询对象中加入分组的字段，以确定结果来自哪一个分组
mysql> select gender, count(*) from emp group by gender;
+--------+----------+
| gender | count(*) |
+--------+----------+
| f      |        6 |
| m      |        4 |
+--------+----------+
2 rows in set (0.00 sec)

-- 1(3). 在select后的查询对象加入了非分组字段的字段，则报错
mysql> select workaddress, count(*) from emp group by gender;
ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.emp.workaddress' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

-- 1(4). 使用多个分组字段进行查询
mysql> select gender, workaddress, count(*) from emp group by gender, workaddress;
+--------+-------------+----------+
| gender | workaddress | count(*) |
+--------+-------------+----------+
| f      | Beijing     |        4 |
| m      | Beijing     |        3 |
| m      | Shanghai    |        1 |
| f      | Shanghai    |        1 |
| f      | Tianjin     |        1 |
+--------+-------------+----------+
5 rows in set (0.00 sec)
```

> 例子12. 包含分组前和分组后的过滤条件进行分组查询
```mysql
-- 1(1). 包含了分组前(age < 45)和分组后(count(*) >= 2)过滤条件的分组查询
mysql> select workaddress, count(*) from emp where age < 45 group by workaddress having count(*) >= 2;
+-------------+----------+
| workaddress | count(*) |
+-------------+----------+
| Beijing     |        5 |
| Shanghai    |        2 |
+-------------+----------+
2 rows in set (0.00 sec)

-- 1(2). 使用别名代替聚合函数进行分组前后过滤, 其中as是可以省略的
mysql> select workaddress, count(*) as address_count from emp where age < 45 group by workaddress having address_count >= 2;
+-------------+---------------+
| workaddress | address_count |
+-------------+---------------+
| Beijing     |             5 |
| Shanghai    |             2 |
+-------------+---------------+
2 rows in set (0.01 sec)
``` 

# 5.5排序查询

```mysql
select fields ... from table_name order by Field1 Order1, Field2 Order2, ..;
```
- sql支持多个字段排序
- 在前面的字段优先级高于在后面的字段
  - 意思：先以`field1`进行排序，当`field1`相同时，才使用`field2`进行排序，以此类推
- 每个字段的排序方式应排序方法:
  - `ASC` ：升序排序，默认值
  - `DESC`：降序排序

- 当存在两条数据在order中无法排出先后顺序时，就按照数据库中的顺序进行排序？

> 例子13.  使用排序查询
```mysql
-- 1. 根据某一字段排序所有数据
mysql> select * from emp order by age;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|    9 | 9      | i    | f      |   45 | 123452389012345678 | Beijing     | 2010-04-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
10 rows in set (0.00 sec)

-- 2. 在分组查询中对结果进行排序
mysql> select workaddress, count(*) address_count from emp where age < 45 group by workaddress having address_count >= 2 order by address_count;
+-------------+---------------+
| workaddress | address_count |
+-------------+---------------+
| Shanghai    |             2 |
| Beijing     |             5 |
+-------------+---------------+
2 rows in set (0.00 sec)
```


# 5.6分页查询

```mysql
select Fields, ... from table name Limit StartIndex, RecordNumber;
```
- `StartIndex` ：返回结果的起始下标 (第一条数据下标为0)，默认为0
- `RecordNumber` ：返回结果的数量
- **不同DMBS使用不同的语句实现分页查询**，mysql的是`limit`
- 当limit选择的范围超出结果数目时，则只返回结果存在的位置：
  - 例如10条数据，`limit 5, 20` 只返回`5,6,7,8,9`这几条
  - 例如10条数据，`limit 20, 5` 返回一个空集

> 例子14. 
```mysql

-- 1(1). 查询不同范围的结果
mysql> select * from emp limit 0, 5;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    1 | 1      | a    | f      |   20 | 123456789012345678 | Beijing     | 2000-01-01 |
|    2 | 2      | b    | m      |   18 | 123456789012345678 | Beijing     | 2005-09-01 |
|    3 | 3      | c    | m      |   38 | 123456789712345678 | Shanghai    | 2005-08-01 |
|    4 | 4      | d    | f      |   18 | 123456757012345678 | Beijing     | 2009-12-01 |
|    5 | 5      | e    | f      |   20 | 123456789012345678 | Shanghai    | 2007-07-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)

-- 1(2). 查询不同范围的结果，当limit范围未完全超出数据条目数量
mysql> select * from emp limit 5, 10;
+------+--------+------+--------+------+--------------------+-------------+------------+
| id   | workno | name | gender | age  | idcard             | workaddress | entrydate  |
+------+--------+------+--------+------+--------------------+-------------+------------+
|    6 | 6      | f    | m      |   28 | 12345678901234567X | Beijing     | 2006-01-01 |
|    7 | 7      | g    | m      |   48 | 123456789212345678 | Beijing     | 2005-05-01 |
|    8 | 8      | hh   | f      |   38 | 123451389012345678 | Tianjin     | 2015-05-01 |
|    9 | 9      | i    | f      |   45 | 123452389012345678 | Beijing     | 2010-04-01 |
|   10 | 10     | j    | f      |   18 | NULL               | Beijing     | 2012-06-01 |
+------+--------+------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)

-- 1(3). 查询不同范围的结果，当limit范围完全超出了数据条目数量，返回空集合
mysql> select * from emp limit 20, 5;
Empty set (0.00 sec)
```